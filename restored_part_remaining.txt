        return res.status(404).json({ message: "Ticket not found" });
      }

      res.json(ticket);
    } catch (error) {
      console.error("Error updating ticket status:", error);
      res.status(500).json({ message: "Failed to update ticket status" });
    }
  });

  // Update a support ticket's priority
  app.patch('/api/threads/:id/ticket-priority', isAuthenticated, isAdmin, async (req: any, res) => {
    try {
      const ticketId = req.params.id;
      const { priority } = req.body;

      if (!priority) {
        return res.status(400).json({ message: "Priority is required" });
      }

      const validPriorities = ['low', 'normal', 'high', 'urgent'];
      if (!validPriorities.includes(priority)) {
        return res.status(400).json({ message: "Invalid priority value" });
      }

      const ticket = await storage.updateTicketPriority(ticketId, priority);
      if (!ticket) {
        return res.status(404).json({ message: "Ticket not found" });
      }

      res.json(ticket);
    } catch (error) {
      console.error("Error updating ticket priority:", error);
      res.status(500).json({ message: "Failed to update ticket priority" });
    }
  });

  // Update a support ticket's assignee
  app.patch('/api/threads/:id/ticket-assign', isAuthenticated, isAdmin, async (req: any, res) => {
    try {
      const ticketId = req.params.id;
      const { assignedAdminId } = req.body;

      const ticket = await storage.updateTicketAssignee(ticketId, assignedAdminId);
      if (!ticket) {
        return res.status(404).json({ message: "Ticket not found" });
      }

      res.json(ticket);
    } catch (error) {
      console.error("Error updating ticket assignee:", error);
      res.status(500).json({ message: "Failed to update ticket assignee" });
    }
  });

  // Admin analytics summary
  app.get('/api/admin/analytics', isAuthenticated, isAdmin, async (req: any, res) => {
    try {
      const summary = await storage.getAnalyticsSummary();
      return res.json(summary);
    } catch (err) {
      console.error('Analytics error', err);
      return res.status(500).json({ error: 'Failed to fetch analytics' });
    }
  });

  // ========================================================================
  // AI Assistant Chat (Gemini 1.5 Flash)
  // ========================================================================
  app.post("/api/assistant/chat", async (req: any, res) => {
    try {
      const userId = req.user ? (req.user.claims?.sub || req.user.id) : null;
      const { message, history } = req.body as {
        message?: string;
        history?: ChatHistoryItem[];
      };

      if (!message || typeof message !== "string") {
        return res.status(400).json({ message: "message is required" });
      }

      const safeHistory: ChatHistoryItem[] = Array.isArray(history)
        ? history
            .filter((h: any) => h && typeof h.content === "string")
            .map((h: any) => ({
              role: h.role === "assistant" ? "assistant" : "user",
              content: h.content,
            }))
        : [];

      let reply = "";

      // Priority: HF Inference API (if configured)
      const hfApiKey = process.env.HF_API_KEY;
      const hfModel = process.env.HF_MODEL || "deepseek-ai/DeepSeek-V3.2:novita";

      // If the configured HF model looks like a modern/chat model (e.g. contains
      // "llama" or a provider slash), prefer the router endpoint which is
      // required by many newer models. Set HF_USE_ROUTER at runtime so
      // `askHuggingFace` will use the router path.
      try {
        const m = String(hfModel || "").toLowerCase();
        if (!process.env.HF_USE_ROUTER && (m.includes("llama") || hfModel.includes("/"))) {
          process.env.HF_USE_ROUTER = "1";
          console.debug("HF_USE_ROUTER enabled for model:", hfModel);
        }
      } catch (e) {
        /* ignore */
      }

      if (hfApiKey) {
        try {
          const prompt = formatChatPrompt(message, safeHistory);
          reply = await askHuggingFace(hfModel, prompt, hfApiKey);
        } catch (hfErr) {
          console.error("HF Inference failed, falling back to Gemini/local:", hfErr);
          reply = await askSupportBot(message, safeHistory);
        }
      } else {
        // Fallback: Gemini or local
        reply = await askSupportBot(message, safeHistory);
      }

      // NOTE: For now we just return the reply.
      // Later, we can also persist this into message_threads/messages
      // so admins can review conversations.

      res.json({ reply, userId });
    } catch (error: any) {
      console.error("Assistant chat error:", error);

      // If the provider returned a quota / rate-limit error, surface a
      // clear 429 to the client and include a Retry-After header when
      // possible so clients/frontend can back off gracefully.
      try {
        if (error && (error.status === 429 || (error?.errorDetails && Array.isArray(error.errorDetails)))) {
          // Try to extract retry info from the provider error details
          let retryDelay: string | null = null;
          const details = error.errorDetails || [];
          for (const d of details) {
            if (d && typeof d === 'object' && d['@type'] && d['@type'].includes('RetryInfo')) {
              retryDelay = d.retryDelay || null;
              break;
            }
          }

          // If we have a retryDelay like "1s" or "30s" attempt to convert
          // it to seconds and set the standard Retry-After header.
          if (retryDelay && typeof retryDelay === 'string') {
            const m = /^\s*(\d+(?:\.\d+)?)(s|m|h)?\s*$/i.exec(retryDelay);
            if (m) {
              const val = Number(m[1]);
              const unit = (m[2] || 's').toLowerCase();
              let seconds = val;
              if (unit === 'm') seconds = val * 60;
              if (unit === 'h') seconds = val * 3600;
              res.setHeader('Retry-After', String(Math.ceil(seconds)));
            }
          }

          return res.status(429).json({ message: "Assistant quota exceeded; please try again later", retryDelay });
        }
      } catch (innerErr) {
        console.error("Error while handling assistant error details:", innerErr);
      }

      res.status(500).json({ message: "Assistant is temporarily unavailable" });
    }
  });

  // ========================================================================
  // File Uploads: Message Attachments
  // ========================================================================
  const uploadsRoot = path.resolve(import.meta.dirname, "..", "attached_assets", "files", "uploads", "messages");
  fs.mkdirSync(uploadsRoot, { recursive: true });

  const storageEngine = multer.diskStorage({
    destination: (_req, _file, cb) => cb(null, uploadsRoot),
    filename: (_req, file, cb) => {
      const timestamp = Date.now();
      const sanitizedOriginal = file.originalname.replace(/[^a-zA-Z0-9._-]/g, "_");
      cb(null, `${timestamp}-${sanitizedOriginal}`);
    },
  });

  const upload = multer({
    storage: storageEngine,
    limits: { fileSize: 10 * 1024 * 1024 }, // 10 MB
    fileFilter: (_req, file, cb) => {
      const allowed = [
        "image/png",
        "image/jpeg",
        "image/gif",
        "application/pdf",
        "text/plain",
      ];
      if (allowed.includes(file.mimetype)) {
        return cb(null, true);
      }
      return cb(new Error("Unsupported file type"));
    },
  });

  app.post('/api/uploads/messages', isAuthenticated, upload.single('file'), async (req: any, res) => {
    try {
      if (!req.file) {
        return res.status(400).json({ message: "No file uploaded" });
      }
      const relativePath = `/attached_assets/files/uploads/messages/${req.file.filename}`;
      res.json({
        filename: req.file.originalname,
        url: relativePath,
        size: req.file.size,
        mimetype: req.file.mimetype,
      });
    } catch (error: any) {
      console.error("Error uploading file:", error);
      res.status(500).json({ message: "Failed to upload file" });
    }
  });

  // ========================================================================
  // Message Routes
  // ========================================================================
  app.get('/api/messages', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims?.sub || req.user.id;
      const messages = await storage.getMessagesByUserId(userId);
      res.json(messages);
    } catch (error) {
      console.error("Error fetching messages:", error);
      res.status(500).json({ message: "Failed to fetch messages" });
    }
  });

  app.post('/api/messages', isAuthenticated, async (req: any, res) => {
    try {
      const senderId = req.user.claims?.sub || req.user.id;
      const receiverId = req.body.receiverId;
      
      const sender = await storage.getUserById(senderId);
      const receiver = await storage.getUserById(receiverId);
      
      if (!sender || !receiver) {
        return res.status(404).json({ message: "User not found" });
      }
      
      const adminUser = await storage.getAdminUser();
      const adminId = adminUser?.id;

      // Allow cases:
      // - admin can send to anyone
      // - messages to admin are allowed
      // - buyers/sellers can message admin
      // Additionally allow buyer -> listing.seller when the message references a listing
      let isAllowed =
        sender.role === 'admin' ||
        receiver.role === 'admin' ||
        (sender.role === 'buyer' && receiverId === adminId) ||
        (sender.role === 'seller' && receiverId === adminId);

      // If this message is intended to contact a listing seller, allow buyer -> seller
      const relatedListingId = req.body?.relatedListingId;
      if (!isAllowed && relatedListingId) {
        try {
          const listing = await storage.getMarketplaceListingById(relatedListingId);
          if (listing && listing.sellerId === receiverId) {
            // Allow buyer to message the listing's seller
            isAllowed = true;
          }
        } catch (err) {
          // don't block on listing lookup errors here; validation will catch missing fields
          console.warn('Failed to lookup listing for message authorization', err);
        }
      }

      if (!isAllowed) {
        return res.status(403).json({ 
          message: "You are not authorized to send this message. For inquiries about listings or projects, contact the listing seller or admin." 
        });
      }
      
      const validatedData = insertMessageSchema.parse({
        ...req.body,
        senderId,
      });
      const idempotencyKey = req.header('Idempotency-Key') || req.header('idempotency-key') || null;
      const message = await storage.createMessageWithIdempotency(idempotencyKey, validatedData);
      
      // Create notification for receiver (persisted to storage)
      await storage.createNotification({
        userId: receiverId,
        type: 'message',
        title: 'New Message',
        message: `${sender.firstName} ${sender.lastName} sent you a message`,
        link: '/messages',
      });
      
      res.json(message);
    } catch (error: any) {
      if (error instanceof ZodError) {
        console.error("Validation error creating message:", formatZodError(error));
        return res.status(400).json({ message: formatZodError(error) });
      }
      console.error("Error creating message:", error);
      res.status(500).json({ message: "Failed to send message" });
    }
  });

  // Admin endpoint to contact seller about a project or listing
  app.post('/api/messages/contact-seller', isAuthenticated, isAdmin, async (req: any, res) => {
    try {
      const adminId = req.user.claims?.sub || req.user.id;
      const { projectId, listingId, sellerId } = req.body;

      if (!projectId && !listingId) {
        return res.status(400).json({ message: "Either projectId or listingId is required" });
      }

      if (!sellerId) {
        return res.status(400).json({ message: "sellerId is required" });
      }

      // Get admin user to verify
      const admin = await storage.getUserById(adminId);
      if (!admin || admin.role !== 'admin') {
        return res.status(403).json({ message: "Only admins can use this endpoint" });
      }

      // Check if thread already exists
      const existingThreads = await storage.getAllMessageThreads();
      let existingThread = existingThreads.find(t => 
        t.type === 'admin_to_seller' &&
        t.adminId === adminId &&
        t.sellerId === sellerId &&
        (projectId ? t.projectId === projectId : t.listingId === listingId)
      );

      if (existingThread) {
        // Thread exists, return it
        return res.json({ thread: existingThread, existed: true });
      }

      // Create new thread
      let threadTitle = '';
      if (projectId) {
        const project = await storage.getProjectById(projectId);
        if (!project) {
          return res.status(404).json({ message: "Project not found" });
        }
        threadTitle = `Admin inquiry about project: ${project.name}`;
      } else if (listingId) {
        const listing = await storage.getMarketplaceListingById(listingId);
        if (!listing) {
          return res.status(404).json({ message: "Listing not found" });
        }
        threadTitle = `Admin inquiry about listing: ${listing.title}`;
      }

      const newThread = await storage.createMessageThread({
        title: threadTitle,
        type: 'admin_to_seller',
        projectId: projectId || null,
        listingId: listingId || null,
        buyerId: null,
        sellerId,
        adminId,
        createdBy: adminId,
        context: 'general',
        status: 'open',
      });

      res.json({ thread: newThread, existed: false });
    } catch (error: any) {
      console.error("Error creating admin-seller thread:", error);
      res.status(500).json({ message: "Failed to create thread" });
    }
  });

  app.get('/api/conversations/:userId', isAuthenticated, async (req: any, res) => {
    try {
      const currentUserId = req.user.claims?.sub || req.user.id;
      const otherUserId = req.params.userId;
      const messages = await storage.getConversation(currentUserId, otherUserId);
      res.json(messages);
    } catch (error) {
      console.error("Error fetching conversation:", error);
      res.status(500).json({ message: "Failed to fetch conversation" });
    }
  });

  app.get('/api/messages/:id/details', isAuthenticated, async (req, res) => {
    try {
  const messageId = req.params.id;
  const currentUserId = (req as any).user?.claims?.sub || (req as any).user?.id;
  console.log(`Fetching message details for id=${messageId} (user=${currentUserId})`);
      const messageDetails = await storage.getMessageWithSenderDetails(messageId);
      if (!messageDetails) {
        console.warn(`Message not found: id=${messageId}`);
        return res.status(404).json({ message: "Message not found" });
      }

      // Mark message as read for the current user if it's addressed to them
      try {
        if (messageDetails.message && messageDetails.message.receiverId === currentUserId) {
          await storage.markMessageAsRead(messageId);
        }
      } catch (err) {
        console.error(`Failed to mark message read for id=${messageId}:`, err);
      }

      // Log minimal details for debugging and return the payload the client expects
      console.log(`Returning message details for id=${messageId}: sender=${messageDetails.sender?.id}`);
      res.json(messageDetails);
    } catch (error) {
      console.error("Error fetching message details:", error);
      res.status(500).json({ message: "Failed to fetch message details" });
    }
  });

  // Close a conversation (mark all messages between the two participants as closed)
  app.patch('/api/messages/:id/close', isAuthenticated, async (req: any, res) => {
    try {
      const messageId = req.params.id;
      const currentUserId = req.user.claims?.sub || req.user.id;

      // Load message details to ensure user is participant or admin
      const messageDetails = await storage.getMessageWithSenderDetails(messageId);
      if (!messageDetails) return res.status(404).json({ message: 'Message not found' });

      const main = messageDetails.message;
      const isParticipant = [main.senderId, main.receiverId].includes(currentUserId);
      const user = await storage.getUser(currentUserId);
      const isAdminUser = user?.role === 'admin';

      if (!isParticipant && !isAdminUser) {
        return res.status(403).json({ message: 'Not authorized to close this conversation' });
      }

      await storage.closeConversationByMessageId(messageId);
      res.json({ success: true });
    } catch (error) {
      console.error('Error closing conversation:', error);
      res.status(500).json({ message: 'Failed to close conversation' });
    }
  });

  app.get('/api/messages/check-contact', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims?.sub || req.user.id;
      const { projectId, listingId } = req.query;

      if (!userId) {
        return res.status(400).json({ error: 'User ID is required' });
      }

      if (projectId) {
        const hasContacted = await storage.checkUserHasContactedAboutProject(userId, projectId as string);
        return res.json({ hasContacted });
      }

      if (listingId) {
        const hasContacted = await storage.checkUserHasContactedAboutListing(userId, listingId as string);
        return res.json({ hasContacted });
      }
      
      return res.status(400).json({ error: 'Either projectId or listingId is required' });
    } catch (error) {
      console.error("Error checking contact status:", error);
      return res.status(500).json({ error: 'Internal server error while checking contact status' });
      res.status(500).json({ message: "Failed to check contact status" });
    }
  });

  // Return a user's public details (admins can view any user; users can view themselves)
  app.get('/api/users/:id', isAuthenticated, async (req: any, res) => {
    try {
      const currentUserId = req.user?.claims?.sub || req.user?.id;
      const targetId = req.params.id;

      // Allow if requesting own profile or admin
      const requestingUser = await storage.getUser(currentUserId);
      const isAdminUser = requestingUser?.role === 'admin';
      if (!isAdminUser && currentUserId !== targetId) {
        return res.status(403).json({ message: 'Not authorized to view this user' });
      }

      const user = await storage.getUserById(targetId);
      if (!user) return res.status(404).json({ message: 'User not found' });
      const profile = await storage.getUserProfile(targetId);

      // Include listings and recent messages when admin or requesting own profile
      let listings = null;
      let recentMessages = null;
      try {
        listings = await storage.getListingsBySellerId(targetId);
      } catch (err) {
        listings = null;
      }

      // Only include message previews for admin users or the owner
      if (isAdminUser || currentUserId === targetId) {
        try {
          const msgs = await storage.getMessagesByUserId(targetId);
          // provide a small preview: last 5 messages
          recentMessages = (msgs || []).slice(0, 5).map(m => ({ id: m.id, content: m.content, createdAt: m.createdAt, senderId: m.senderId, receiverId: m.receiverId }));
        } catch (err) {
          recentMessages = null;
        }
      }

      res.json({ user, profile, listings, recentMessages });
    } catch (error) {
      console.error('Error fetching user details:', error);
      res.status(500).json({ message: 'Failed to fetch user' });
    }
  });

  // Public profile endpoint (no authentication) with limited fields and public listings
  app.get('/api/public/users/:id', async (req: any, res) => {
    try {
      const targetId = req.params.id;
      const user = await storage.getUserById(targetId);
      if (!user) return res.status(404).json({ message: 'User not found' });
      const profile = await storage.getUserProfile(targetId);

  // Public listings: only return listings with status 'active' or published
  let publicListings: any[] = [];
      try {
        const allListings = await storage.getListingsBySellerId(targetId);
        publicListings = (allListings || []).filter(l => (l.status || '').toLowerCase() === 'active');
      } catch (err) {
        publicListings = [];
      }

      // Build public payload (exclude email/phone)
      const publicUser = { id: user.id, firstName: user.firstName, lastName: user.lastName, role: user.role };
      const publicProfile = { companyName: profile?.companyName, location: profile?.location, bio: profile?.bio };

      res.json({ user: publicUser, profile: publicProfile, listings: publicListings });
    } catch (error) {
      console.error('Error fetching public user profile:', error);
      res.status(500).json({ message: 'Failed to fetch public profile' });
    }
  });

  // ========================================================================
  // Blog Routes
  // ========================================================================
  app.get('/api/blog', async (req, res) => {
    try {
      const posts = await storage.getBlogPosts(true);
      res.json(posts);
    } catch (error) {
      console.error("Error fetching blog posts:", error);
      res.status(500).json({ message: "Failed to fetch blog posts" });
    }
  });

  app.get('/api/blog/:slug', async (req, res) => {
    try {
      const post = await storage.getBlogPostBySlug(req.params.slug);
      if (!post) {
        return res.status(404).json({ message: "Blog post not found" });
      }
      res.json(post);
    } catch (error) {
      console.error("Error fetching blog post:", error);
      res.status(500).json({ message: "Failed to fetch blog post" });
    }
  });

  app.post('/api/blog', isAuthenticated, isAdmin, async (req: any, res) => {
    try {
      const authorId = req.user.claims?.sub || req.user.id;
      const validatedData = insertBlogPostSchema.parse({
        ...req.body,
        authorId,
      });
      const post = await storage.createBlogPost(validatedData);
      
      // Log activity
      try {
        await storage.createActivityLog({
          userId: authorId,
          activityType: 'blog_post_created',
          description: `Created blog post: "${post.title || post.id}"`,
            ipAddress: (req.headers['x-forwarded-for'] as string)?.split(',')[0]?.trim() || (req.headers['x-real-ip'] as string) || req.ip || req.socket.remoteAddress || null,
          userAgent: req.get('user-agent') || null,
          metadata: { postId: post.id, slug: post.slug },
        });
      } catch (logError) {
        console.error('[ACTIVITY LOG] Failed to log blog post creation:', logError);
      }
      
      res.json(post);
    } catch (error: any) {
      if (error instanceof ZodError) {
        console.error("Validation error creating blog post:", formatZodError(error));
        return res.status(400).json({ message: formatZodError(error) });
      }
      console.error("Error creating blog post:", error);
      res.status(500).json({ message: "Failed to create blog post" });
    }
  });

  app.patch('/api/blog/:id/publish', isAuthenticated, isAdmin, async (req, res) => {
    try {
      const post = await storage.publishBlogPost(req.params.id);
      res.json(post);
    } catch (error) {
      console.error("Error publishing blog post:", error);
      res.status(500).json({ message: "Failed to publish blog post" });
    }
  });

  app.patch('/api/blog/:id', isAuthenticated, isAdmin, async (req, res) => {
    try {
      const validatedData = insertBlogPostSchema.partial().parse(req.body);
      const post = await storage.updateBlogPost(req.params.id, validatedData);
      res.json(post);
    } catch (error: any) {
      if (error instanceof ZodError) {
        console.error("Validation error updating blog post:", formatZodError(error));
        return res.status(400).json({ message: formatZodError(error) });
      }
      console.error("Error updating blog post:", error);
      res.status(500).json({ message: "Failed to update blog post" });
    }
  });

  app.delete('/api/blog/:id', isAuthenticated, isAdmin, async (req, res) => {
    try {
      await storage.deleteBlogPost(req.params.id);
      res.json({ message: "Blog post deleted successfully" });
    } catch (error) {
      console.error("Error deleting blog post:", error);
      res.status(500).json({ message: "Failed to delete blog post" });
    }
  });

  app.get('/api/blog/admin/all', isAuthenticated, isAdmin, async (req, res) => {
    try {
      const posts = await storage.getBlogPosts(false);
      res.json(posts);
    } catch (error) {
      console.error("Error fetching all blog posts:", error);
      res.status(500).json({ message: "Failed to fetch blog posts" });
    }
  });

  // ========================================================================
  // Sustainability Routes
  // ========================================================================
  app.get('/api/sustainability', async (req, res) => {
    try {
      const items = await storage.getSustainabilityContent();
      res.json(items);
    } catch (error) {
      console.error("Error fetching sustainability content:", error);
      res.status(500).json({ message: "Failed to fetch sustainability content" });
    }
  });

  app.post('/api/sustainability', isAuthenticated, isAdmin, async (req, res) => {
    try {
      const validatedData = insertSustainabilityContentSchema.parse(req.body);
      const item = await storage.createSustainabilityContent(validatedData);
      res.json(item);
    } catch (error: any) {
      if (error instanceof ZodError) {
        console.error("Validation error creating sustainability content:", formatZodError(error));
        return res.status(400).json({ message: formatZodError(error) });
      }
      console.error("Error creating sustainability content:", error);
      res.status(500).json({ message: "Failed to create sustainability content" });
    }
  });

  app.patch('/api/sustainability/:id', isAuthenticated, isAdmin, async (req, res) => {
    try {
      const validatedData = insertSustainabilityContentSchema.partial().parse(req.body);
      const item = await storage.updateSustainabilityContent(req.params.id, validatedData);
      res.json(item);
    } catch (error: any) {
      if (error instanceof ZodError) {
        console.error("Validation error updating sustainability content:", formatZodError(error));
        return res.status(400).json({ message: formatZodError(error) });
      }
      console.error("Error updating sustainability content:", error);
      res.status(500).json({ message: "Failed to update sustainability content" });
    }
  });

  app.delete('/api/sustainability/:id', isAuthenticated, isAdmin, async (req, res) => {
    try {
      await storage.deleteSustainabilityContent(req.params.id);
      res.json({ message: "Sustainability content deleted successfully" });
    } catch (error) {
      console.error("Error deleting sustainability content:", error);
      res.status(500).json({ message: "Failed to delete sustainability content" });
    }
  });

  // ========================================================================
  // Contact Routes
  // ========================================================================
  app.post('/api/contact', async (req, res) => {
    try {
      const validatedData = insertContactSubmissionSchema.parse(req.body);
      const submission = await storage.createContactSubmission(validatedData);
      
      // Also create an internal support thread so admins see the submission in Messages
      try {
        const adminUser = await storage.getAdminUser();
        let thread: any = null;
        if (adminUser) {
          // If the requester is authenticated, create a thread owned by them so
          // the conversation appears in their Messages view. Otherwise create
          // an internal admin-side thread for unauthenticated submissions.
          const requesterId = (req as any).user ? ((req as any).user.claims?.sub || (req as any).user.id) : null;

          if (requesterId) {
            thread = await storage.createMessageThread({
              title: submission.subject || 'Contact Admin',
              type: 'support',
              projectId: null,
              listingId: null,
              buyerId: requesterId,
              sellerId: null,
              adminId: adminUser.id,
              createdBy: requesterId,
              context: 'support',
              status: 'open',
              isAdminSupport: true,
              assignedAdminId: adminUser.id,
              ticketStatus: 'open',
            } as any);

            const content = `Contact submission from ${submission.name || ''} <${submission.email || ''}>\nPhone: ${submission.phone || 'N/A'}\n\n${submission.message}\n\nView thread: /dashboard/messages?threadId=${thread.id}`;
            await storage.createMessage({
              threadId: thread.id,
              senderId: requesterId,
              receiverId: adminUser.id,
              subject: submission.subject,
              content,
              context: 'support',
              isAutoRelay: false,
            } as any);

            await storage.updateThreadLastMessage(thread.id);
          } else {
            // Unauthenticated submission: create an internal admin thread and a relay message
            thread = await storage.createMessageThread({
              title: submission.subject || 'Contact Form Submission',
              type: 'support',
              projectId: null,
              listingId: null,
              buyerId: null,
              sellerId: null,
              adminId: adminUser.id,
              createdBy: adminUser.id,
              context: 'support',
              status: 'open',
              isAdminSupport: true,
              assignedAdminId: adminUser.id,
              ticketStatus: 'open',
            } as any);

            const content = `Contact submission from ${submission.name} <${submission.email}>\nPhone: ${submission.phone || 'N/A'}\n\n${submission.message}\n\nView thread: /dashboard/messages?threadId=${thread.id}`;
            await storage.createMessage({
              threadId: thread.id,
              senderId: adminUser.id,
              receiverId: adminUser.id,
              subject: submission.subject,
              content,
              context: 'support',
              isAutoRelay: true,
            } as any);

            await storage.updateThreadLastMessage(thread.id);
          }
        }
      } catch (err) {
        console.error('Failed to create support thread for contact submission:', err);
      }

      // Notify all admin users about the new contact submission
      try {
        const adminUsers = await storage.getUsersByRole('admin');
        for (const admin of adminUsers) {
          await storage.createNotification({
            userId: admin.id,
            type: 'message',
            title: 'New Contact Submission',
            message: `${submission.name || 'Visitor'} submitted a contact: ${submission.subject || 'No subject'}`,
            link: thread ? `/dashboard/messages?threadId=${thread.id}` : `/dashboard/messages`,
          });
        }
      } catch (err) {
        console.error('Failed to create admin notifications for contact submission:', err);
      }
      
      res.json(submission);
    } catch (error: any) {
      if (error instanceof ZodError) {
        console.error("Validation error submitting contact form:", formatZodError(error));
        return res.status(400).json({ message: formatZodError(error) });
      }
      console.error("Error submitting contact form:", error);
      res.status(500).json({ message: "Failed to submit contact form" });
    }
  });

  app.get('/api/contact/submissions', isAuthenticated, isAdmin, async (req, res) => {
    try {
      const submissions = await storage.getContactSubmissions();
      res.json(submissions);
    } catch (error) {
      console.error("Error fetching contact submissions:", error);
      res.status(500).json({ message: "Failed to fetch submissions" });
    }
  });

  app.patch('/api/contact/submissions/:id', isAuthenticated, isAdmin, async (req, res) => {
    try {
      const { status } = req.body;
      if (!status || !['new', 'contacted', 'resolved'].includes(status)) {
        return res.status(400).json({ message: "Invalid status value" });
      }
      const submission = await storage.updateContactSubmissionStatus(req.params.id, status);
      res.json(submission);
    } catch (error) {
      console.error("Error updating contact submission:", error);
      res.status(500).json({ message: "Failed to update submission" });
    }
  });

  app.get('/api/contact/settings', async (req, res) => {
    try {
      const settings = await storage.getContactSettings();
      res.json(settings);
    } catch (error) {
      console.error("Error fetching contact settings:", error);
      res.status(500).json({ message: "Failed to fetch contact settings" });
    }
  });

  app.patch('/api/contact/settings', isAuthenticated, isAdmin, async (req, res) => {
    try {
      const settings = await storage.updateContactSettings(req.body);
      res.json(settings);
    } catch (error) {
      console.error("Error updating contact settings:", error);
      res.status(500).json({ message: "Failed to update contact settings" });
    }
  });

  // ========================================================================
  // Admin Routes
  // ========================================================================
  app.get('/api/admin/verification-queue', isAuthenticated, isAdmin, async (req, res) => {
    try {
      const listings = await storage.getPendingListings();
      res.json(listings);
    } catch (error) {
      console.error("Error fetching verification queue:", error);
      res.status(500).json({ message: "Failed to fetch verification queue" });
    }
  });

  // Consolidated admin statistics used by the Admin overview dashboard
  app.get('/api/admin/stats', isAuthenticated, isAdmin, async (req, res) => {
    try {
      // Fetch users via storage so legacy/linked users are included
      const allUsers = await storage.getAllUsers();
      const totalUsers = allUsers.length;
      const admins = allUsers.filter(u => u.role === 'admin').length;
      const sellers = allUsers.filter(u => u.role === 'seller').length;
      const buyers = allUsers.filter(u => u.role === 'buyer').length;

      // Listings
      const pendingListings = await storage.getPendingListings();
      const allListings = await db.select().from(marketplaceListings);
      const totalListings = allListings.length;
      const approvedListings = allListings.filter((l: any) => l.status === 'approved').length;

      // Projects
      const allProjects = await db.select().from(projects);
      const totalProjects = allProjects.length;
      const activeProjects = allProjects.filter((p: any) => p.status === 'active').length;

      // Messages
      const allMessages = await db.select().from(messages);
      const totalMessages = allMessages.length;
      const unreadMessages = allMessages.filter((m: any) => !m.read).length;

      // Buyer requests / RFQs
      const allBuyerRequests = await db.select().from(buyerRequests);
      const totalRFQs = allBuyerRequests.length;

      return res.json({
        totalUsers,
        admins,
        sellers,
        buyers,
        pendingVerifications: pendingListings.length,
        totalListings,
        approvedListings,
        totalProjects,
        activeProjects,
        totalMessages,
        unreadMessages,
        totalRFQs,
      });
    } catch (error) {
      console.error('Error fetching admin stats:', error);
      res.status(500).json({ message: 'Failed to fetch admin stats' });
    }
  });

  app.post('/api/admin/verify/:id', isAuthenticated, isAdmin, async (req: any, res) => {
    try {
      const reviewerId = req.user.claims?.sub || req.user.id;
      const listingId = req.params.id;
      const listing = await storage.getListing(listingId);
      await storage.approveListing(listingId, reviewerId);
      
      // Log activity
      if (listing?.sellerId) {
        try {
          await storage.createActivityLog({
            userId: listing.sellerId,
            activityType: 'listing_approved',
            description: `Listing "${listing.title || listingId}" was approved by admin`,
            ipAddress: req.ip || (req.headers['x-forwarded-for'] as string)?.split(',')[0]?.trim() || null,
            userAgent: req.get('user-agent') || null,
            metadata: { listingId, reviewerId },
          });
        } catch (logError) {
          console.error('[ACTIVITY LOG] Failed to log listing approval:', logError);
        }
      }
      
      res.json({ message: "Listing approved successfully" });
    } catch (error) {
      console.error("Error approving listing:", error);
      res.status(500).json({ message: "Failed to approve listing" });
    }
  });

  app.post('/api/admin/reject/:id', isAuthenticated, isAdmin, async (req: any, res) => {
    try {
      const reviewerId = req.user.claims?.sub || req.user.id;
      const listingId = req.params.id;
      const listing = await storage.getListing(listingId);
      await storage.rejectListing(listingId, reviewerId);
      
      // Log activity
      if (listing?.sellerId) {
        try {
          await storage.createActivityLog({
            userId: listing.sellerId,
            activityType: 'listing_rejected',
            description: `Listing "${listing.title || listingId}" was rejected by admin`,
            ipAddress: req.ip || (req.headers['x-forwarded-for'] as string)?.split(',')[0]?.trim() || null,
            userAgent: req.get('user-agent') || null,
            metadata: { listingId, reviewerId },
          });
        } catch (logError) {
          console.error('[ACTIVITY LOG] Failed to log listing rejection:', logError);
        }
      }
      
      res.json({ message: "Listing rejected successfully" });
    } catch (error) {
      console.error("Error rejecting listing:", error);
      res.status(500).json({ message: "Failed to reject listing" });
    }
  });

  app.get('/api/admin/users', isAuthenticated, isAdmin, async (req, res) => {
    try {
      const users = await storage.getAllUsers();
      
      // Fetch user profiles for phone numbers and company names
      const profiles = await db.select().from(userProfiles);
      const profileMap = new Map(profiles.map(p => [p.userId, p]));
      
      // Fetch admin permissions for admin users
      const adminUsers = users.filter(u => u.role === 'admin');
      const adminPermissionsMap = new Map();
      
      for (const adminUser of adminUsers) {
        try {
          const permissions = await storage.getAdminPermissions(adminUser.id);
          if (permissions) {
            adminPermissionsMap.set(adminUser.id, permissions);
          }
        } catch (error) {
          // If getting permissions fails, continue without it
        }
      }
      
      // Merge test user data from testUsersStore and profile data
      const mergedUsers = users.map(user => {
        const profile = profileMap.get(user.id);
        const testUser = testUsersStore.get(user.id);
        const adminPermissions = adminPermissionsMap.get(user.id);
        
        return {
          ...user,
          phoneNumber: profile?.phoneNumber || '-',
          companyName: profile?.companyName || '-',
          // For admin user management, always trust the real database values
          // for membershipTier and verificationStatus, not any testUser overrides.
          ...(adminPermissions && {
            adminRole: adminPermissions.adminRole,
          }),
        };
      });
      
      res.json(mergedUsers);
    } catch (error) {
      console.error("Error fetching users:", error);
      res.status(500).json({ message: "Failed to fetch users" });
    }
  });

  app.post('/api/admin/users', isAuthenticated, isAdmin, async (req: any, res) => {
    try {
      const { email, password, username, firstName, lastName, role } = req.body || {};
      if (!email || !role) {
        return res.status(400).json({ message: 'Email and role are required' });
      }
      
      // Hash password if provided
      let hashedPassword: string | undefined = undefined;
      if (password) {
        const saltRounds = 10;
        hashedPassword = await bcrypt.hash(password, saltRounds);
        console.log('[CREATE USER] Password hashed for user:', email);
      }
      
      const user = await storage.upsertUser({
        email,
        firstName,
        lastName,
        password: hashedPassword,
        username: username || undefined,
        // allow setting role on creation
        // @ts-ignore
        role: role,
      });
      
      // If admin, ensure a permissions row exists
      if (role === 'admin') {
        await storage.upsertAdminPermissions({ adminUserId: user.id } as any);
      }
      
      console.log('[CREATE USER] User created successfully:', { id: user.id, email, username, role });
      res.json(user);
    } catch (error) {
      console.error('Error creating user:', error);
      res.status(500).json({ message: 'Failed to create user' });
    }
  });

  app.patch('/api/admin/users/:id/role', isAuthenticated, isAdmin, async (req, res) => {
    try {
      const { role } = req.body;
      if (!role || !['admin', 'buyer', 'seller'].includes(role)) {
        return res.status(400).json({ message: "Invalid role" });
      }
      const user = await storage.updateUserRole(req.params.id, role);
      res.json(user);
    } catch (error) {
      console.error("Error updating user role:", error);
      res.status(500).json({ message: "Failed to update user role" });
    }
  });

  // Update user information (name, email, phone, company, password, username)
  app.patch('/api/admin/users/:id/info', isAuthenticated, isAdmin, async (req, res) => {
    try {
      const { firstName, lastName, email, phoneNumber, companyName, password, username } = req.body;
      const userId = req.params.id;

      // Update user basic info
      if (firstName || lastName || email || password || username) {
        const updateData: any = {};
        if (firstName !== undefined) updateData.firstName = firstName;
        if (lastName !== undefined) updateData.lastName = lastName;
        if (email !== undefined) updateData.email = email;
        if (username !== undefined) updateData.username = username;
        
        // Hash password if provided
        if (password) {
          const saltRounds = 10;
          updateData.password = await bcrypt.hash(password, saltRounds);
          console.log('[UPDATE USER] Password updated and hashed for user:', userId);
        }
        
        await db.update(users).set(updateData).where(eq(users.id, userId));
      }

      // Update user profile info (phone, company)
      if (phoneNumber !== undefined || companyName !== undefined) {
        const profileUpdateData: any = {};
        if (phoneNumber !== undefined) profileUpdateData.phoneNumber = phoneNumber;
        if (companyName !== undefined) profileUpdateData.companyName = companyName;

        // Get or create user profile
        const existingProfile = await db.select().from(userProfiles).where(eq(userProfiles.userId, userId)).limit(1);
        
        if (existingProfile.length > 0) {
          await db.update(userProfiles).set(profileUpdateData).where(eq(userProfiles.userId, userId));
        } else {
          await db.insert(userProfiles).values({
            userId,
            ...profileUpdateData,
            profileType: 'individual'
          });
        }
      }

      // Return updated user
      const updatedUser = await storage.getUser(userId);
      res.json(updatedUser);
    } catch (error) {
      console.error("Error updating user information:", error);
      res.status(500).json({ message: "Failed to update user information" });
    }
  });

  app.delete('/api/admin/users/:id', isAuthenticated, isAdmin, async (req, res) => {
    try {
      await storage.deleteUser(req.params.id);
      res.json({ message: "User deleted successfully" });
    } catch (error) {
      console.error("Error deleting user:", error);
      res.status(500).json({ message: "Failed to delete user" });
    }
  });

  // Return marketplace listings for a specific user (admin only)
  app.get('/api/admin/users/:id/listings', isAuthenticated, isAdmin, async (req: any, res) => {
    try {
      const sellerId = req.params.id;
      const listings = await storage.getListingsBySellerId(sellerId);
      res.json(listings);
    } catch (error) {
      console.error('Error fetching user listings (admin):', error);
      res.status(500).json({ message: 'Failed to fetch user listings' });
    }
  });

  // ========================================================================
  // Admin Role Management Routes
  // ========================================================================
  
  // Get all available admin roles and their default permissions
  app.get('/api/admin/roles', isAuthenticated, isAdmin, async (req, res) => {
    try {
      const { ROLE_PERMISSIONS, getAdminRoleDisplayName } = await import('./rbac');
      const roles = Object.keys(ROLE_PERMISSIONS).map(role => ({
        value: role,
        label: getAdminRoleDisplayName(role as any),
        permissions: ROLE_PERMISSIONS[role as keyof typeof ROLE_PERMISSIONS],
      }));
      res.json(roles);
    } catch (error) {
      console.error('Error fetching admin roles:', error);
      res.status(500).json({ message: 'Failed to fetch admin roles' });
    }
  });

  // Get users filtered by role (for tabbed user management interface)
  app.get('/api/admin/users/by-role/:role', isAuthenticated, isAdmin, async (req, res) => {
    try {
      const { role } = req.params;
      if (!['admin', 'buyer', 'seller'].includes(role)) {
        return res.status(400).json({ message: 'Invalid role' });
      }
      const allUsers = await storage.getAllUsers();
      const filteredUsers = allUsers.filter(u => u.role === role);
      
      // For admin users, include their permissions and admin role
      if (role === 'admin') {
        const usersWithPermissions = await Promise.all(
          filteredUsers.map(async (user) => {
            const permissions = await storage.getAdminPermissions(user.id);
            return {
              ...user,
              adminRole: permissions?.adminRole || null,
              permissions: permissions || null,
            };
          })
        );
        res.json(usersWithPermissions);
      } else {
        res.json(filteredUsers);
      }
    } catch (error) {
      console.error('Error fetching users by role:', error);
      res.status(500).json({ message: 'Failed to fetch users' });
    }
  });

  // Assign or update admin role for a user
  app.patch('/api/admin/users/:id/admin-role', isAuthenticated, isAdmin, async (req: any, res) => {
    try {
      const { adminRole } = req.body;
      const userId = req.params.id;
      
      if (!adminRole || !['super_admin', 'verification_admin', 'content_admin', 'support_admin', 'analytics_admin'].includes(adminRole)) {
        return res.status(400).json({ message: 'Invalid admin role' });
      }

      // Check if user is an admin
      const user = await storage.getUser(userId);
      if (!user || user.role !== 'admin') {
        return res.status(400).json({ message: 'User must be an admin' });
      }

      // Get default permissions for the role
      const { ROLE_PERMISSIONS } = await import('./rbac');
      const defaultPermissions = ROLE_PERMISSIONS[adminRole as keyof typeof ROLE_PERMISSIONS];

      // Upsert admin permissions with the new role and its default permissions
      const permissions = await storage.upsertAdminPermissions({
        adminUserId: userId,
        adminRole: adminRole as any,
        ...defaultPermissions,
      } as any);

      res.json(permissions);
    } catch (error) {
      console.error('Error updating admin role:', error);
      res.status(500).json({ message: 'Failed to update admin role' });
    }
  });

  // Update custom permissions for an admin user (Super Admin only)
  app.put('/api/admin/users/:id/custom-permissions', isAuthenticated, isAdmin, async (req: any, res) => {
    try {
      const userId = req.params.id;
      const permissions = req.body;

      // Only super admins can update custom permissions
      if (req.adminPermissions?.adminRole !== 'super_admin') {
        return res.status(403).json({ message: 'Only Super Admins can update custom permissions' });
      }

      // Update admin permissions
      const updated = await storage.updateAdminPermissions({
        adminUserId: userId,
        ...permissions,
      } as any);

      res.json(updated);
    } catch (error) {
      console.error('Error updating custom permissions:', error);
      res.status(500).json({ message: 'Failed to update permissions' });
    }
  });

  // ========================================================================
  // Activity Log Routes
  // ========================================================================
  // Admin audit logs with admin user details (for monitoring admin changes)
  app.get('/api/admin/audit-logs', isAuthenticated, isAdmin, async (req, res) => {
    try {
      const limit = req.query.limit ? parseInt(req.query.limit as string) : 500;
      const fromDate = req.query.from as string | undefined;
      const toDate = req.query.to as string | undefined;
      const action = req.query.action as string | undefined;
      
      let auditLogs = await storage.getAdminAuditLogs();
      
      // Filter by action type if provided
      if (action && action !== "all") {
        auditLogs = auditLogs.filter(log => log.action === action);
      }
      
      // Filter by date range if provided
      if (fromDate || toDate) {
        auditLogs = auditLogs.filter(log => {
          const logDate = new Date(log.createdAt);
          if (fromDate && logDate < new Date(fromDate)) return false;
          if (toDate) {
            const toDateEnd = new Date(toDate);
            toDateEnd.setHours(23, 59, 59, 999); // Include entire end date
            if (logDate > toDateEnd) return false;
          }
          return true;
        });
      }
      
      res.json(auditLogs.slice(0, limit));
    } catch (error) {
      console.error("Error fetching admin audit logs:", error);
      res.status(500).json({ message: "Failed to fetch audit logs" });
    }
  });

  // Helper endpoint to log admin actions
  app.post('/api/admin/audit-log', isAuthenticated, isAdmin, async (req: any, res) => {
    try {
      const adminId = req.user.claims?.sub || req.user.id;
      const { action, targetType, targetId, changes } = req.body;

      if (!action || !targetType) {
        return res.status(400).json({ message: "Missing required fields" });
      }

      await db.insert(adminAuditLogs).values({
        adminId,
        action,
        targetType,
        targetId: targetId || null,
        changes: changes || null,
        ipAddress: req.ip,
        userAgent: req.get('user-agent'),
        createdAt: new Date(),
      });

      res.json({ message: "Audit log recorded" });
    } catch (error) {
      console.error("Error logging admin action:", error);
      res.status(500).json({ message: "Failed to log action" });
    }
  });

  app.get('/api/admin/activity-logs', isAuthenticated, isAdmin, async (req, res) => {
    try {
      const limit = req.query.limit ? parseInt(req.query.limit as string) : 500;
      const activityType = req.query.activityType as string | undefined;
      const userId = req.query.userId as string | undefined;
      const logs = await storage.getActivityLogs(limit);
      
      // Filter out admin activities - only show buyer and seller activities
      let filteredLogs = logs.filter(log => {
        // Exclude logs where user is an admin
        return log.user?.role !== 'admin';
      });
      
      // Filter by activity type if provided
      if (activityType) {
        filteredLogs = filteredLogs.filter(log => log.activityType === activityType);
      }
      if (userId) {
        filteredLogs = filteredLogs.filter(log => log.userId === userId);
      }
      
      res.json(filteredLogs);
    } catch (error) {
      console.error("Error fetching activity logs:", error);
      res.status(500).json({ message: "Failed to fetch activity logs" });
    }
  });

  app.get('/api/activity-logs/me', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims?.sub || req.user.id;
      const limit = req.query.limit ? parseInt(req.query.limit as string) : 50;
      const logs = await storage.getUserActivityLogs(userId, limit);
      res.json(logs);
    } catch (error) {
      console.error("Error fetching user activity logs:", error);
      res.status(500).json({ message: "Failed to fetch activity logs" });
    }
  });

  // ========================================================================
  // Notification Routes
  // ========================================================================
  app.get('/api/notifications', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims?.sub || req.user.id;
      const notifications = await storage.getUserNotifications(userId);
      res.json(notifications);
    } catch (error) {
      console.error("Error fetching notifications:", error);
      res.status(500).json({ message: "Failed to fetch notifications" });
    }
  });

  app.get('/api/notifications/unread-count', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims?.sub || req.user.id;
      const count = await storage.getUnreadNotificationCount(userId);
      res.json({ count });
    } catch (error) {
      console.error("Error fetching unread count:", error);
      res.status(500).json({ message: "Failed to fetch unread count" });
    }
  });

  app.post('/api/notifications/:id/read', isAuthenticated, async (req, res) => {
    try {
      await storage.markNotificationAsRead(req.params.id);
      res.json({ message: "Notification marked as read" });
    } catch (error) {
      console.error("Error marking notification as read:", error);
      res.status(500).json({ message: "Failed to mark notification as read" });
    }
  });

  app.post('/api/notifications/mark-all-read', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims?.sub || req.user.id;
      await storage.markAllNotificationsAsRead(userId);
      res.json({ message: "All notifications marked as read" });
    } catch (error) {
      console.error("Error marking all notifications as read:", error);
      res.status(500).json({ message: "Failed to mark all notifications as read" });
    }
  });

  // ========================================================================
  // Dashboard Stats Routes
  // ========================================================================
  app.get('/api/dashboard/stats', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims?.sub || req.user.id;
      const [listingsCount, unreadMessagesCount, interestsCount] = await Promise.all([
        storage.getUserListingsCount(userId),
        storage.getUserUnreadMessagesCount(userId),
        storage.getUserInterestsCount(userId),
      ]);
      res.json({
        listingsCount,
        unreadMessagesCount,
        interestsCount,
      });
    } catch (error) {
      console.error("Error fetching dashboard stats:", error);
      res.status(500).json({ message: "Failed to fetch dashboard stats" });
    }
  });

  // ========================================================================
  // Video Routes
  // ========================================================================
  app.get('/api/videos/active', async (req, res) => {
    try {
      const videos = await storage.getActiveVideos();
      res.json(videos);
    } catch (error) {
      console.error("Error fetching active videos:", error);
      res.status(500).json({ message: "Failed to fetch active videos" });
    }
  });

  app.get('/api/videos', isAuthenticated, isAdmin, async (req, res) => {
    try {
      const videos = await storage.getAllVideos();
      res.json(videos);
    } catch (error) {
      console.error("Error fetching videos:", error);
      res.status(500).json({ message: "Failed to fetch videos" });
    }
  });

  app.post('/api/videos', isAuthenticated, isAdmin, async (req, res) => {
    try {
      const validatedData = insertVideoSchema.parse(req.body);
      const video = await storage.createVideo(validatedData);
      res.json(video);
    } catch (error: any) {
      if (error instanceof ZodError) {
        console.error("Validation error creating video:", formatZodError(error));
        return res.status(400).json({ message: formatZodError(error) });
      }
      console.error("Error creating video:", error);
      res.status(500).json({ message: "Failed to create video" });
    }
  });

  app.patch('/api/videos/:id', isAuthenticated, isAdmin, async (req, res) => {
    try {
      const validatedData = updateVideoSchema.parse({ ...req.body, id: req.params.id });
      const video = await storage.updateVideo(validatedData);
      res.json(video);
    } catch (error: any) {
      if (error instanceof ZodError) {
        console.error("Validation error updating video:", formatZodError(error));
        return res.status(400).json({ message: formatZodError(error) });
      }
      console.error("Error updating video:", error);
      res.status(500).json({ message: "Failed to update video" });
    }
  });

  app.post('/api/videos/:id/toggle-active', isAuthenticated, isAdmin, async (req, res) => {
    try {
      const video = await storage.toggleVideoActive(req.params.id);
      res.json(video);
    } catch (error: any) {
      console.error("Error toggling video active status:", error);
      res.status(400).json({ message: error.message || "Failed to toggle video status" });
    }
  });

  app.delete('/api/videos/:id', isAuthenticated, isAdmin, async (req, res) => {
    try {
      await storage.deleteVideo(req.params.id);
      res.json({ message: "Video deleted successfully" });
    } catch (error) {
      console.error("Error deleting video:", error);
      res.status(500).json({ message: "Failed to delete video" });
    }
  });

  // ============================================================================
  // Admin Settings API Routes
  // ============================================================================

  // Platform Settings
  app.get('/api/admin/settings/platform', isAuthenticated, isAdmin, async (req, res) => {
    try {
      const settings = await storage.getAllPlatformSettings();
      res.json(settings);
    } catch (error) {
      console.error("Error fetching platform settings:", error);
      res.status(500).json({ message: "Failed to fetch platform settings" });
    }
  });

  app.post('/api/admin/settings/platform', isAuthenticated, isAdmin, async (req: any, res) => {
    try {
      const validatedData = insertPlatformSettingSchema.parse({ ...req.body, updatedBy: req.user.id });
      const setting = await storage.createPlatformSetting(validatedData);
      res.json(setting);
    } catch (error: any) {
      if (error instanceof ZodError) {
        return res.status(400).json({ message: formatZodError(error) });
      }
      console.error("Error creating platform setting:", error);
      res.status(500).json({ message: "Failed to create platform setting" });
    }
  });

  app.patch('/api/admin/settings/platform/:id', isAuthenticated, isAdmin, async (req: any, res) => {
    try {
      // Get the current setting to log the old value
      const currentSetting = await storage.getAllPlatformSettings();
      const existing = currentSetting.find(s => s.id === req.params.id);
      
      const validatedData = updatePlatformSettingSchema.parse({ ...req.body, id: req.params.id, updatedBy: req.user.id });
      const setting = await storage.updatePlatformSetting(validatedData);
      
      // Log the change to audit table
      if (existing && req.body.value !== undefined) {
        await storage.logSettingChange({
          settingKey: existing.key,
          oldValue: existing.value,
          newValue: req.body.value,
          changedBy: req.user.id,
        });
      }
      
      res.json(setting);
    } catch (error: any) {
      if (error instanceof ZodError) {
        return res.status(400).json({ message: formatZodError(error) });
      }
      console.error("Error updating platform setting:", error);
      res.status(500).json({ message: "Failed to update platform setting" });
    }
  });

  app.delete('/api/admin/settings/platform/:id', isAuthenticated, isAdmin, async (req, res) => {
    try {
      await storage.deletePlatformSetting(req.params.id);
      res.json({ message: "Platform setting deleted successfully" });
    } catch (error) {
      console.error("Error deleting platform setting:", error);
      res.status(500).json({ message: "Failed to delete platform setting" });
    }
  });

  // Get settings by category
  app.get('/api/admin/settings/platform/category/:category', isAuthenticated, isAdmin, async (req, res) => {
    try {
      const settings = await storage.getPlatformSettingsByCategory(req.params.category);
      res.json(settings);
    } catch (error) {
      console.error("Error fetching settings by category:", error);
      res.status(500).json({ message: "Failed to fetch settings" });
    }
  });

  // Get settings audit logs
  app.get('/api/admin/settings/audit', isAuthenticated, isAdmin, async (req, res) => {
    try {
      const { settingKey, limit } = req.query;
      const logs = await storage.getSettingsAuditLogs(
        settingKey as string | undefined,
        limit ? parseInt(limit as string) : 50
      );
      res.json(logs);
    } catch (error) {
      console.error("Error fetching settings audit logs:", error);
      res.status(500).json({ message: "Failed to fetch audit logs" });
    }
  });

  // Email Templates
  app.get('/api/admin/settings/email-templates', isAuthenticated, isAdmin, async (req, res) => {
    try {
      const templates = await storage.getAllEmailTemplates();
      res.json(templates);
    } catch (error) {
      console.error("Error fetching email templates:", error);
      res.status(500).json({ message: "Failed to fetch email templates" });
    }
  });

  app.post('/api/admin/settings/email-templates', isAuthenticated, isAdmin, async (req, res) => {
    try {
      const validatedData = insertEmailTemplateSchema.parse(req.body);
      const template = await storage.createEmailTemplate(validatedData);
      res.json(template);
    } catch (error: any) {
      if (error instanceof ZodError) {
        return res.status(400).json({ message: formatZodError(error) });
      }
      console.error("Error creating email template:", error);
      res.status(500).json({ message: "Failed to create email template" });
    }
  });

  app.patch('/api/admin/settings/email-templates/:id', isAuthenticated, isAdmin, async (req, res) => {
    try {
      const validatedData = updateEmailTemplateSchema.parse({ ...req.body, id: req.params.id });
      const template = await storage.updateEmailTemplate(validatedData);
      res.json(template);
    } catch (error: any) {
      if (error instanceof ZodError) {
        return res.status(400).json({ message: formatZodError(error) });
      }
      console.error("Error updating email template:", error);
      res.status(500).json({ message: "Failed to update email template" });
    }
  });

  app.delete('/api/admin/settings/email-templates/:id', isAuthenticated, isAdmin, async (req, res) => {
    try {
      await storage.deleteEmailTemplate(req.params.id);
      res.json({ message: "Email template deleted successfully" });
    } catch (error) {
      console.error("Error deleting email template:", error);
      res.status(500).json({ message: "Failed to delete email template" });
    }
  });

  // Login History
  app.get('/api/admin/settings/login-history', isAuthenticated, isAdmin, async (req, res) => {
    try {
      const userId = req.query.userId as string | undefined;
      const history = await storage.getLoginHistory(userId);
      res.json(history);
    } catch (error) {
      console.error("Error fetching login history:", error);
      res.status(500).json({ message: "Failed to fetch login history" });
    }
  });

  // Verification Rules
  app.get('/api/admin/settings/verification-rules', isAuthenticated, isAdmin, async (req, res) => {
    try {
      const rules = await storage.getAllVerificationRules();
      res.json(rules);
    } catch (error) {
      console.error("Error fetching verification rules:", error);
      res.status(500).json({ message: "Failed to fetch verification rules" });
    }
  });

  app.post('/api/admin/settings/verification-rules', isAuthenticated, isAdmin, async (req, res) => {
    try {
      const validatedData = insertVerificationRuleSchema.parse(req.body);
      const rule = await storage.createVerificationRule(validatedData);
      res.json(rule);
    } catch (error: any) {
      if (error instanceof ZodError) {
        return res.status(400).json({ message: formatZodError(error) });
      }
      console.error("Error creating verification rule:", error);
      res.status(500).json({ message: "Failed to create verification rule" });
    }
  });

  app.patch('/api/admin/settings/verification-rules/:id', isAuthenticated, isAdmin, async (req, res) => {
    try {
      const validatedData = updateVerificationRuleSchema.parse({ ...req.body, id: req.params.id });
      const rule = await storage.updateVerificationRule(validatedData);
      res.json(rule);
    } catch (error: any) {
      if (error instanceof ZodError) {
        return res.status(400).json({ message: formatZodError(error) });
      }
      console.error("Error updating verification rule:", error);
      res.status(500).json({ message: "Failed to update verification rule" });
    }
  });

  app.delete('/api/admin/settings/verification-rules/:id', isAuthenticated, isAdmin, async (req, res) => {
    try {
      await storage.deleteVerificationRule(req.params.id);
      res.json({ message: "Verification rule deleted successfully" });
    } catch (error) {
      console.error("Error deleting verification rule:", error);
      res.status(500).json({ message: "Failed to delete verification rule" });
    }
  });

  // Document Templates
  app.get('/api/admin/settings/document-templates', isAuthenticated, isAdmin, async (req, res) => {
    try {
      const templates = await storage.getAllDocumentTemplates();
      res.json(templates);
    } catch (error) {
      console.error("Error fetching document templates:", error);
      res.status(500).json({ message: "Failed to fetch document templates" });
    }
  });

  app.post('/api/admin/settings/document-templates', isAuthenticated, isAdmin, async (req, res) => {
    try {
      const validatedData = insertDocumentTemplateSchema.parse(req.body);
      const template = await storage.createDocumentTemplate(validatedData);
      res.json(template);
    } catch (error: any) {
      if (error instanceof ZodError) {
        return res.status(400).json({ message: formatZodError(error) });
      }
      console.error("Error creating document template:", error);
      res.status(500).json({ message: "Failed to create document template" });
    }
  });

  app.patch('/api/admin/settings/document-templates/:id', isAuthenticated, isAdmin, async (req, res) => {
    try {
      const validatedData = updateDocumentTemplateSchema.parse({ ...req.body, id: req.params.id });
      const template = await storage.updateDocumentTemplate(validatedData);
      res.json(template);
    } catch (error: any) {
      if (error instanceof ZodError) {
        return res.status(400).json({ message: formatZodError(error) });
      }
      console.error("Error updating document template:", error);
      res.status(500).json({ message: "Failed to update document template" });
    }
  });

  app.delete('/api/admin/settings/document-templates/:id', isAuthenticated, isAdmin, async (req, res) => {
    try {
      await storage.deleteDocumentTemplate(req.params.id);
      res.json({ message: "Document template deleted successfully" });
    } catch (error) {
      console.error("Error deleting document template:", error);
      res.status(500).json({ message: "Failed to delete document template" });
    }
  });

  // Admin Audit Logs
  app.get('/api/admin/settings/audit-logs', isAuthenticated, isAdmin, async (req, res) => {
    try {
      const adminId = req.query.adminId as string | undefined;
      const logs = await storage.getAdminAuditLogs(adminId);
      res.json(logs);
    } catch (error) {
      console.error("Error fetching audit logs:", error);
      res.status(500).json({ message: "Failed to fetch audit logs" });
    }
  });

  // User Management (Admin Controls)
  app.patch('/api/admin/users/:id/password-reset', isAuthenticated, isAdmin, async (req, res) => {
    try {
      const { newPassword } = req.body;
      if (!newPassword || newPassword.length < 6) {
        return res.status(400).json({ message: "Password must be at least 6 characters long" });
      }
      const hashedPassword = await bcrypt.hash(newPassword, 10);
      await storage.updateUserPassword(req.params.id, hashedPassword);
      
      // Log audit trail
      await storage.logAdminAudit({
        adminId: (req as any).user.id,
        action: 'user_password_reset',
        targetType: 'user',
        targetId: req.params.id,
        changes: { resetBy: 'admin' },
        ipAddress: req.ip,
        userAgent: req.get('user-agent'),
      });
      
      res.json({ message: "Password reset successfully" });
    } catch (error) {
      console.error("Error resetting user password:", error);
      res.status(500).json({ message: "Failed to reset password" });
    }
  });

  app.post('/api/admin/users/:id/force-logout', isAuthenticated, isAdmin, async (req, res) => {
    try {
      await storage.forceUserLogout(req.params.id);
      
      // Log audit trail
      await storage.logAdminAudit({
        adminId: (req as any).user.id,
        action: 'user_force_logout',
        targetType: 'user',
        targetId: req.params.id,
        changes: {},
        ipAddress: req.ip,
        userAgent: req.get('user-agent'),
      });
      
      res.json({ message: "User logged out successfully" });
    } catch (error) {
      console.error("Error forcing user logout:", error);
      res.status(500).json({ message: "Failed to force logout" });
    }
  });

  app.patch('/api/admin/users/:id/role', isAuthenticated, isAdmin, async (req, res) => {
    try {
      const { role } = req.body;
      if (!['admin', 'buyer', 'seller'].includes(role)) {
        return res.status(400).json({ message: "Invalid role" });
      }
      
      const updatedUser = await storage.updateUserRole(req.params.id, role);
      
      // Log audit trail
      await storage.logAdminAudit({
        adminId: (req as any).user.id,
        action: 'user_role_updated',
        targetType: 'user',
        targetId: req.params.id,
        changes: { newRole: role },
        ipAddress: req.ip,
        userAgent: req.get('user-agent'),
      });
      
      res.json(updatedUser);
    } catch (error) {
      console.error("Error updating user role:", error);
      res.status(500).json({ message: "Failed to update user role" });
    }
  });

  // Account Settings (for current admin user)
  app.patch('/api/account/profile', isAuthenticated, async (req: any, res) => {
    try {
      const { firstName, lastName, email, profileImageUrl } = req.body;
      const updatedUser = await storage.updateUserInfo(req.user.id, {
        firstName,
        lastName,
        email,
        profileImageUrl,
      });
      res.json(updatedUser);
    } catch (error) {
      console.error("Error updating profile:", error);
      res.status(500).json({ message: "Failed to update profile" });
    }
  });

  app.post('/api/account/password-change', isAuthenticated, async (req: any, res) => {
    try {
      const { currentPassword, newPassword } = req.body;
      
      if (!currentPassword || !newPassword) {
        return res.status(400).json({ message: "Current and new password required" });
      }
      
      if (newPassword.length < 6) {
        return res.status(400).json({ message: "New password must be at least 6 characters long" });
      }
      
      // Verify current password
      const user = await storage.getUserById(req.user.id);
      if (!user || !user.password) {
        return res.status(400).json({ message: "Invalid user" });
      }
      
      const isValidPassword = await bcrypt.compare(currentPassword, user.password);
      if (!isValidPassword) {
        return res.status(400).json({ message: "Current password is incorrect" });
      }
      
      // Update to new password
      const hashedPassword = await bcrypt.hash(newPassword, 10);
      await storage.updateUserPassword(req.user.id, hashedPassword);
      
      res.json({ message: "Password updated successfully" });
    } catch (error) {
      console.error("Error changing password:", error);
      res.status(500).json({ message: "Failed to change password" });
    }
  });

  app.get('/api/account/login-history', isAuthenticated, async (req: any, res) => {
    try {
      const history = await storage.getLoginHistory(req.user.id);
      res.json(history);
    } catch (error) {
      console.error("Error fetching login history:", error);
      res.status(500).json({ message: "Failed to fetch login history" });
    }
  });

  // Two-Factor Authentication
  app.get('/api/account/2fa/status', isAuthenticated, async (req: any, res) => {
    try {
      const twoFAStatus = await storage.getTwoFactorAuthStatus(req.user.id);
      res.json(twoFAStatus);
    } catch (error) {
      console.error("Error fetching 2FA status:", error);
      res.status(500).json({ message: "Failed to fetch 2FA status" });
    }
  });

  app.post('/api/account/2fa/enable', isAuthenticated, async (req: any, res) => {
    try {
      // In a real implementation, this would generate a TOTP secret and QR code
      // For now, we'll create a placeholder
      await storage.enableTwoFactorAuth(req.user.id);
      res.json({ message: "2FA enabled successfully" });
    } catch (error) {
      console.error("Error enabling 2FA:", error);
      res.status(500).json({ message: "Failed to enable 2FA" });
    }
  });

  app.post('/api/account/2fa/disable', isAuthenticated, async (req: any, res) => {
    try {
      await storage.disableTwoFactorAuth(req.user.id);
      res.json({ message: "2FA disabled successfully" });
    } catch (error) {
      console.error("Error disabling 2FA:", error);
      res.status(500).json({ message: "Failed to disable 2FA" });
    }
  });

  // ========================================================================
  // Seller Verification Routes
  // ========================================================================
  
  // Create verification request (Seller only)
  app.post('/api/verification/request', isAuthenticated, async (req: any, res) => {
    try {
      if (req.user.role !== 'seller') {
        return res.status(403).json({ message: "Only sellers can request verification" });
      }

      // Ensure seller exists in database (important for demo users)
      let seller = await storage.getUser(req.user.id);
      if (!seller) {
        console.log('[VERIFICATION] Creating missing seller in database:', req.user.id);
        try {
          await storage.upsertUser({
            id: req.user.id,
            email: req.user.email || 'seller@fusionmining.com',
            firstName: req.user.firstName || 'Seller',
            lastName: req.user.lastName || 'User',
          });
          console.log('[VERIFICATION] User upserted successfully');
          
          await storage.updateUserRole(req.user.id, 'seller');
          console.log('[VERIFICATION] User role updated to seller');
          
          // Verify the user was created
          seller = await storage.getUser(req.user.id);
          if (!seller) {
            throw new Error('User was not created in database after upsert');
          }
          console.log('[VERIFICATION] User confirmed in database');
        } catch (userError) {
          console.error('[VERIFICATION] Error creating user:', userError);
          throw userError;
        }
      } else {
        console.log('[VERIFICATION] Seller already exists in database');
      }

      const request = await storage.createVerificationRequest(req.user.id);
      res.json(request);
    } catch (error) {
      console.error("Error creating verification request:", error);
      res.status(500).json({ message: "Failed to create verification request" });
    }
  });

  // Submit verification request (Seller only) - sends request for review
  app.post('/api/verification/submit', isAuthenticated, async (req: any, res) => {
    try {
      if (req.user.role !== 'seller') {
        return res.status(403).json({ message: "Only sellers can submit verification" });
      }

      const request = await storage.getVerificationRequestBySellerId(req.user.id);
      if (!request) {
        return res.status(404).json({ message: "Verification request not found" });
      }

      // Check if request has at least one document
      const documents = await storage.getDocumentsByRequestId(request.id);
      if (!documents || documents.length === 0) {
        return res.status(400).json({ message: "Please upload at least one document before submitting" });
      }

      // Update request status to pending
      const updatedRequest = await storage.updateVerificationRequestStatus(request.id, 'pending');
      const updatedDocuments = await storage.getDocumentsByRequestId(request.id);
      
      // Create notification for seller
      const seller = await storage.getUser(req.user.id);
      if (seller) {
        await storage.createNotification({
          userId: req.user.id,
          type: 'seller_verification',
          title: 'Verification Request Submitted',
          message: 'Your seller verification request has been submitted for review. We will review it within 2-3 business days.',
          link: '/dashboard/seller-verification',
        });
      }
      
      // Create notification for all admins
      const adminUser = await storage.getAdminUser();
      if (adminUser) {
        await storage.createNotification({
          userId: adminUser.id,
          type: 'seller_verification',
          title: 'New Seller Verification Request',
          message: `${seller?.firstName} ${seller?.lastName} (${seller?.email}) submitted a new verification request.`,
          link: '/admin?tab=seller-verification',
        });
      }
      
      console.log('[VERIFICATION] Request submitted:', request.id, 'Status changed to pending');
      res.json({ ...updatedRequest, documents: updatedDocuments });
    } catch (error) {
      console.error("Error submitting verification request:", error);
      res.status(500).json({ message: "Failed to submit verification request" });
    }
  });

  // Get current user's verification request (Seller)
  app.get('/api/verification/my-request', isAuthenticated, async (req: any, res) => {
    try {
      if (req.user.role !== 'seller') {
        return res.status(403).json({ message: "Only sellers can access this endpoint" });
      }

      const request = await storage.getVerificationRequestBySellerId(req.user.id);
      
      if (!request) {
        return res.json(null);
      }

      // Also get documents for this request
      const documents = await storage.getDocumentsByRequestId(request.id);
      res.json({ ...request, documents });
    } catch (error) {
      console.error("Error fetching verification request:", error);
      res.status(500).json({ message: "Failed to fetch verification request" });
    }
  });

  // Get all verification requests (Admin only)
  app.get('/api/verification/requests', isAuthenticated, async (req: any, res) => {
    try {
      if (req.user.role !== 'admin') {
        return res.status(403).json({ message: "Admin access required" });
      }

      const requests = await storage.getAllVerificationRequests();
      res.json(requests);
    } catch (error) {
      console.error("Error fetching verification requests:", error);
      res.status(500).json({ message: "Failed to fetch verification requests" });
    }
  });

  // Get pending verification requests (Admin only)
  app.get('/api/verification/requests/pending', isAuthenticated, async (req: any, res) => {
    try {
      if (req.user.role !== 'admin') {
        return res.status(403).json({ message: "Admin access required" });
      }

      const requests = await storage.getAllPendingVerificationRequests();
      res.json(requests);
    } catch (error) {
      console.error("Error fetching pending verification requests:", error);
      res.status(500).json({ message: "Failed to fetch pending verification requests" });
    }
  });

  // Get documents for a verification request (Admin only)
  app.get('/api/verification/documents/:requestId', isAuthenticated, async (req: any, res) => {
    try {
      if (req.user.role !== 'admin') {
        return res.status(403).json({ message: "Admin access required" });
      }

      const documents = await storage.getDocumentsByRequestId(req.params.requestId);
      res.json(documents);
    } catch (error) {
      console.error("Error fetching verification documents:", error);
      res.status(500).json({ message: "Failed to fetch verification documents" });
    }
  });

  // Approve verification request (Admin only)
  app.post('/api/verification/approve/:id', isAuthenticated, async (req: any, res) => {
    try {
      if (req.user.role !== 'admin') {
        return res.status(403).json({ message: "Admin access required" });
      }

      const request = await storage.approveVerificationRequest(req.params.id, req.user.id);
      res.json(request);
    } catch (error) {
      console.error("Error approving verification request:", error);
      res.status(500).json({ message: "Failed to approve verification request" });
    }
  });

  // Reject verification request (Admin only)
  app.post('/api/verification/reject/:id', isAuthenticated, async (req: any, res) => {
    try {
      if (req.user.role !== 'admin') {
        return res.status(403).json({ message: "Admin access required" });
      }

      const { reason } = req.body;
      if (!reason) {
        return res.status(400).json({ message: "Rejection reason is required" });
      }

      const request = await storage.rejectVerificationRequest(req.params.id, req.user.id, reason);
      res.json(request);
    } catch (error) {
      console.error("Error rejecting verification request:", error);
      res.status(500).json({ message: "Failed to reject verification request" });
    }
  });

  // ========================================================================
  // File Uploads: Verification Documents
  // ========================================================================
  const verificationUploadsRoot = path.resolve(import.meta.dirname, "..", "attached_assets", "files", "uploads", "verification");
  fs.mkdirSync(verificationUploadsRoot, { recursive: true });

  const verificationStorageEngine = multer.diskStorage({
    destination: (_req, _file, cb) => cb(null, verificationUploadsRoot),
    filename: (_req, file, cb) => {
      const timestamp = Date.now();
      const sanitizedOriginal = file.originalname.replace(/[^a-zA-Z0-9._-]/g, "_");
      cb(null, `${timestamp}-${sanitizedOriginal}`);
    },
  });

  const verificationUpload = multer({
    storage: verificationStorageEngine,
    limits: { fileSize: 20 * 1024 * 1024 }, // 20 MB for verification documents
    fileFilter: (_req, file, cb) => {
      const allowed = [
        "application/pdf",
        "image/png",
        "image/jpeg",
        "image/jpg",
        "application/msword",
        "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
      ];
      if (allowed.includes(file.mimetype)) {
        return cb(null, true);
      }
      return cb(new Error("Unsupported file type. Please upload PDF, JPG, PNG, or DOC files."));
    },
  });

  // Upload verification file endpoint
  app.post('/api/verification/upload', isAuthenticated, verificationUpload.single('file'), async (req: any, res) => {
    try {
      if (req.user.role !== 'seller') {
        return res.status(403).json({ message: "Only sellers can upload verification documents" });
      }

      if (!req.file) {
        return res.status(400).json({ message: "No file uploaded" });
      }

      const { requestId, documentType } = req.body;
      
      if (!requestId || !documentType) {
        return res.status(400).json({ message: "Request ID and document type are required" });
      }

      // Verify the request belongs to the current user
      const request = await storage.getVerificationRequestById(requestId);
      if (!request || request.sellerId !== req.user.id) {
        return res.status(403).json({ message: "Invalid verification request" });
      }

      const relativePath = `/attached_assets/files/uploads/verification/${req.file.filename}`;
      
      // Create document record in database
      const document = await storage.createVerificationDocument({
        requestId,
        documentType,
        fileName: req.file.originalname,
        filePath: relativePath,
        fileSize: req.file.size,
        mimeType: req.file.mimetype,
      });

      res.json({
        document,
        filename: req.file.originalname,
        url: relativePath,
        size: req.file.size,
        mimetype: req.file.mimetype,
      });
    } catch (error: any) {
      console.error("Error uploading verification document:", error);
      res.status(500).json({ message: error.message || "Failed to upload verification document" });
    }
  });

  // ========================================================================
  // Buyer Tier Upgrade Routes (Placeholder - storage methods need to be implemented)
  // ========================================================================
  
  // Create tier upgrade request (Buyer only)
  app.post('/api/buyer/tier-upgrade-request', isAuthenticated, async (req: any, res) => {
    try {
      if (req.user.role !== 'buyer') {
        return res.status(403).json({ message: "Only buyers can request tier upgrades" });
      }

      const { requestedTier } = req.body;
      if (!requestedTier || !['standard', 'premium'].includes(requestedTier)) {
        return res.status(400).json({ message: "Invalid tier. Must be 'standard' or 'premium'" });
      }

      // Create and store in in-memory map
      const newRequest: BuyerUpgradeRequest = {
        id: `tier-upgrade-${Date.now()}`,
        userId: req.user.id,
        buyerEmail: req.user.email || '',
        buyerFirstName: req.user.firstName || '',
        buyerLastName: req.user.lastName || '',
        requestedTier,
        status: 'draft',
        submittedAt: new Date().toISOString(),
        documentCount: 0,
      };
      buyerUpgradeRequests.set(newRequest.id, newRequest);
      res.json(newRequest);
    } catch (error) {
      console.error("Error creating tier upgrade request:", error);
      res.status(500).json({ message: "Failed to create tier upgrade request" });
    }
  });

  // Get current user's tier upgrade request (Buyer)
  app.get('/api/buyer/tier-upgrade-request', isAuthenticated, async (req: any, res) => {
    try {
      if (req.user.role !== 'buyer') {
        return res.status(403).json({ message: "Only buyers can access this endpoint" });
      }

      // Find the user's tier upgrade request from in-memory store
      let userRequest: BuyerUpgradeRequest | null = null;
      for (const request of buyerUpgradeRequests.values()) {
        if (request.userId === req.user.id) {
          userRequest = request;
          break;
        }
      }
      
      res.json(userRequest);
    } catch (error) {
      console.error("Error fetching tier upgrade request:", error);
      res.status(500).json({ message: "Failed to fetch tier upgrade request" });
    }
  });

  // Upload tier upgrade documents (Buyer only)
  app.post('/api/buyer/tier-upgrade/upload', isAuthenticated, verificationUpload.single('file'), async (req: any, res) => {
    try {
      if (req.user.role !== 'buyer') {
        return res.status(403).json({ message: "Only buyers can upload tier upgrade documents" });
      }

      if (!req.file) {
        return res.status(400).json({ message: "No file uploaded" });
      }

      const { requestId, documentType } = req.body;
      
      if (!requestId || !documentType) {
        return res.status(400).json({ message: "Request ID and document type are required" });
      }

      const relativePath = `/attached_assets/files/uploads/verification/${req.file.filename}`;
      
      // For now, return mock data - storage methods to be implemented
      const mockDocument = {
        id: `doc-${Date.now()}`,
        requestId,
        documentType,
        fileName: req.file.originalname,
        filePath: relativePath,
        uploadedAt: new Date().toISOString(),
      };

      res.json({
        document: mockDocument,
        filename: req.file.originalname,
        url: relativePath,
        size: req.file.size,
        mimetype: req.file.mimetype,
      });
    } catch (error: any) {
      console.error("Error uploading tier upgrade document:", error);
      res.status(500).json({ message: error.message || "Failed to upload document" });
    }
  });

  // Submit tier upgrade request (Buyer only)
  app.post('/api/buyer/tier-upgrade/submit', isAuthenticated, async (req: any, res) => {
    try {
      if (req.user.role !== 'buyer') {
        return res.status(403).json({ message: "Only buyers can submit tier upgrade requests" });
      }

      const { requestId } = req.body;
      if (!requestId) {
        return res.status(400).json({ message: "Request ID is required" });
      }

      // Find and update the request in in-memory store
      const request = buyerUpgradeRequests.get(requestId);
      if (!request) {
        return res.status(404).json({ message: "Tier upgrade request not found" });
      }

      if (request.userId !== req.user.id) {
        return res.status(403).json({ message: "Unauthorized - request does not belong to user" });
      }

      // Update status to 'pending'
      request.status = 'pending';
      request.submittedAt = new Date().toISOString();
      buyerUpgradeRequests.set(requestId, request);

      res.json({
        success: true,
        message: "Tier upgrade request submitted successfully",
        status: 'pending',
        submittedAt: new Date().toISOString(),
      });
    } catch (error: any) {
      console.error("Error submitting tier upgrade request:", error);
      res.status(500).json({ message: error.message || "Failed to submit tier upgrade request" });
    }
  });

  // ========================================================================
  // Admin Buyer Tier Upgrade Routes
  // ========================================================================

  // Get pending buyer tier upgrade requests (Admin only)
  app.get('/api/admin/buyer-upgrades/pending', async (req: any, res) => {
    try {
      // In development, allow requests without full auth (mock data)
      const isDev = process.env.NODE_ENV === 'development';
      if (!isDev && !req.user?.id) {
        return res.status(401).json({ message: "Unauthorized" });
      }

      // Return pending requests from in-memory store
      const pendingRequests = getPendingBuyerUpgrades();
      res.json(pendingRequests);
    } catch (error) {
      console.error("Error fetching pending buyer tier upgrades:", error);
      res.status(500).json({ message: "Failed to fetch pending buyer tier upgrades" });
    }
  });

  // Get all buyer tier upgrade requests (Admin only)
  app.get('/api/admin/buyer-upgrades', async (req: any, res) => {
    try {
      // In development, allow requests without full auth (mock data)
      const isDev = process.env.NODE_ENV === 'development';
      if (!isDev && !req.user?.id) {
        return res.status(401).json({ message: "Unauthorized" });
      }

      // Return all requests from in-memory store
      const allRequests = getAllBuyerUpgrades();
      res.json(allRequests);
    } catch (error) {
      console.error("Error fetching buyer tier upgrades:", error);
      res.status(500).json({ message: "Failed to fetch buyer tier upgrades" });
    }
  });

  // Get documents for a buyer tier upgrade request (Admin only)
  app.get('/api/admin/buyer-upgrades/documents/:requestId', async (req: any, res) => {
    // In development, allow requests without full auth (mock data)
    const isDev = process.env.NODE_ENV === 'development';
    if (!isDev && !req.user?.id) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    try {
      const { requestId } = req.params;

      // For now, return mock data - storage methods to be implemented
      const mockDocuments = [
        {
          id: 'doc-1',
          documentType: 'certificate_of_incorporation',
          fileName: 'Company_Certificate.pdf',
          filePath: '/attached_assets/files/uploads/verification/cert.pdf',
          uploadedAt: new Date(Date.now() - 2 * 24 * 60 * 60 * 1000).toISOString(),
        },
        {
          id: 'doc-2',
          documentType: 'company_profile',
          fileName: 'Company_Profile.docx',
          filePath: '/attached_assets/files/uploads/verification/profile.docx',
          uploadedAt: new Date(Date.now() - 2 * 24 * 60 * 60 * 1000).toISOString(),
        },
        {
          id: 'doc-3',
          documentType: 'shareholder_list',
          fileName: 'Shareholders.pdf',
          filePath: '/attached_assets/files/uploads/verification/shareholders.pdf',
          uploadedAt: new Date(Date.now() - 2 * 24 * 60 * 60 * 1000).toISOString(),
        },
        {
          id: 'doc-4',
          documentType: 'tax_certificate',
          fileName: 'Tax_Certificate.pdf',
          filePath: '/attached_assets/files/uploads/verification/tax.pdf',
          uploadedAt: new Date(Date.now() - 2 * 24 * 60 * 60 * 1000).toISOString(),
        },
      ];
      res.json(mockDocuments);
    } catch (error) {
      console.error("Error fetching buyer tier upgrade documents:", error);
      res.status(500).json({ message: "Failed to fetch documents" });
    }
  });

  // Approve buyer tier upgrade request (Admin only)
  app.post('/api/admin/buyer-upgrades/approve/:id', async (req: any, res) => {
    // In development, allow requests without full auth (mock data)
    const isDev = process.env.NODE_ENV === 'development';
    if (!isDev && !req.user?.id) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    try {
      const { id } = req.params;

      // Update in-memory store
      const updated = approveBuyerUpgrade(id);
      if (!updated) {
        return res.status(404).json({ message: "Tier upgrade request not found" });
      }

      // Create notification for buyer
      await storage.createNotification({
        userId: updated.userId,
        type: 'tier_upgrade',
        title: 'Tier Upgrade Approved',
        message: `Congratulations! Your upgrade to ${updated.requestedTier} tier has been approved.`,
        link: '/dashboard',
      });

      res.json({
        success: true,
        message: "Tier upgrade request approved successfully",
        status: 'approved',
        reviewedAt: new Date().toISOString(),
      });
    } catch (error) {
      console.error("Error approving buyer tier upgrade:", error);
      res.status(500).json({ message: "Failed to approve tier upgrade request" });
    }
  });

  // Reject buyer tier upgrade request (Admin only)
  app.post('/api/admin/buyer-upgrades/reject/:id', async (req: any, res) => {
    // In development, allow requests without full auth (mock data)
    const isDev = process.env.NODE_ENV === 'development';
    if (!isDev && !req.user?.id) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    try {
      const { id } = req.params;
      const { reason } = req.body;

      if (!reason) {
        return res.status(400).json({ message: "Rejection reason is required" });
      }

      // Update in-memory store
      const updated = rejectBuyerUpgrade(id, reason);
      if (!updated) {
        return res.status(404).json({ message: "Tier upgrade request not found" });
      }

      // Create notification for buyer
      await storage.createNotification({
        userId: updated.userId,
        type: 'tier_upgrade',
        title: 'Tier Upgrade Rejected',
        message: `Your upgrade request to ${updated.requestedTier} tier was rejected. Reason: ${reason}`,
        link: '/dashboard',
      });

      res.json({
        success: true,
        message: "Tier upgrade request rejected successfully",
        status: 'rejected',
        rejectionReason: reason,
        reviewedAt: new Date().toISOString(),
      });
    } catch (error) {
      console.error("Error rejecting buyer tier upgrade:", error);
      res.status(500).json({ message: "Failed to reject tier upgrade request" });
    }
  });

  // Revert buyer tier upgrade request to draft (Admin only)
  app.post('/api/admin/buyer-upgrades/revert/:id', async (req: any, res) => {
    // In development, allow requests without full auth (mock data)
    const isDev = process.env.NODE_ENV === 'development';
    if (!isDev && !req.user?.id) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    try {
      const { id } = req.params;

      // Update in-memory store
      const updated = revertBuyerUpgrade(id);
      if (!updated) {
        return res.status(404).json({ message: "Tier upgrade request not found" });
      }

      res.json({
        success: true,
        message: "Tier upgrade request reverted to draft successfully",
        status: 'draft',
      });
    } catch (error) {
      console.error("Error reverting buyer tier upgrade:", error);
      res.status(500).json({ message: "Failed to revert tier upgrade request" });
    }
  });

  // ========================================================================
  // Notification Routes
  // ========================================================================

  // Get all notifications for current user

  const httpServer = createServer(app);
  return httpServer;
}
