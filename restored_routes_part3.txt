    try {
      const { type, status } = req.query;
      const isAdmin = req.user && req.user.role === 'admin';
      const listings = await storage.getMarketplaceListings({
        type: type as string,
        status: status as string,
      });
      
      const filteredListings = isAdmin 
        ? listings 
        : listings.filter(l => l.status === 'approved');
      
      res.json(filteredListings);
    } catch (error) {
      console.error("Error fetching listings:", error);
      res.status(500).json({ message: "Failed to fetch listings" });
    }
  });

  // Dashboard: get current user's listings (sellers)
  app.get('/api/dashboard/listings', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims?.sub || req.user.id;
      // If user is seller, return their listings; otherwise return empty array
      const listings = await storage.getListingsBySellerId(userId);
      res.json(listings || []);
    } catch (error) {
      console.error('Error fetching dashboard listings:', error);
      res.status(500).json({ message: 'Failed to fetch dashboard listings' });
    }
  });

  // Return a single listing including basic seller info (used by client when messages
  // don't include the listing payload).
  app.get('/api/marketplace/listings/:id', async (req, res) => {
    try {
      const listingId = req.params.id;
      const listing = await storage.getMarketplaceListingById(listingId);
      if (!listing) return res.status(404).json({ message: 'Listing not found' });
      const seller = listing.sellerId ? await storage.getUserById(listing.sellerId) : null;
      res.json({
        ...listing,
        sellerName: seller ? `${seller.firstName || ''} ${seller.lastName || ''}`.trim() : undefined,
      });
    } catch (error) {
      console.error('Error fetching listing:', error);
      res.status(500).json({ message: 'Failed to fetch listing' });
    }
  });

  app.post('/api/marketplace/listings', isAuthenticated, isSeller, async (req: any, res) => {
    try {
      const sellerId = req.user.claims?.sub || req.user.id;
      const validatedData = insertMarketplaceListingSchema.parse({
        ...req.body,
        sellerId,
      });
      const listing = await storage.createMarketplaceListing(validatedData);
      
      // Log activity
      try {
        await storage.createActivityLog({
          userId: sellerId,
          activityType: 'listing_created',
          description: `Created marketplace listing: "${listing.title || listing.id}"`,
            ipAddress: (req.headers['x-forwarded-for'] as string)?.split(',')[0]?.trim() || (req.headers['x-real-ip'] as string) || req.ip || req.socket.remoteAddress || null,
          userAgent: req.get('user-agent') || null,
          metadata: { listingId: listing.id, listingType: listing.listingType },
        });
      } catch (logError) {
        console.error('[ACTIVITY LOG] Failed to log listing creation:', logError);
      }
      
      res.json(listing);
    } catch (error: any) {
      if (error instanceof ZodError) {
        console.error("Validation error creating listing:", formatZodError(error));
        return res.status(400).json({ message: formatZodError(error) });
      }
      console.error("Error creating listing:", error);
      res.status(500).json({ message: "Failed to create listing" });
    }
  });

  app.get('/api/marketplace/buyer-requests', async (req, res) => {
    try {
      const requests = await storage.getBuyerRequests();
      res.json(requests);
    } catch (error) {
      console.error("Error fetching buyer requests:", error);
      res.status(500).json({ message: "Failed to fetch buyer requests" });
    }
  });

  app.get('/api/buyer-requests/latest', async (req, res) => {
    try {
      const requests = await storage.getBuyerRequests();
      // Get latest 6 active requests, sorted by creation date
      const latestRequests = requests
        .filter(r => r.status === 'active')
        .sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime())
        .slice(0, 6);
      res.json(latestRequests);
    } catch (error) {
      console.error("Error fetching latest buyer requests:", error);
      res.status(500).json({ message: "Failed to fetch latest requests" });
    }
  });

  app.post('/api/marketplace/buyer-requests', isAuthenticated, async (req: any, res) => {
    try {
      const buyerId = req.user.claims?.sub || req.user.id;
      
      // Check tier limits before allowing RFQ creation
      const tierCheck = await storage.checkUserCanCreateRFQ(buyerId);
      if (!tierCheck.allowed) {
        return res.status(403).json({ 
          message: tierCheck.reason || 'You have reached your tier limit for active RFQs',
          tierLimitReached: true
        });
      }
      
      const validatedData = insertBuyerRequestSchema.parse({
        ...req.body,
        buyerId,
      });
      const request = await storage.createBuyerRequest(validatedData);
      
      // Track usage for this month
      const currentMonth = new Date().toISOString().slice(0, 7); // YYYY-MM format
      await storage.incrementUserRFQCount(buyerId, currentMonth);
      
      res.json(request);
    } catch (error: any) {
      if (error instanceof ZodError) {
        console.error("Validation error creating buyer request:", formatZodError(error));
        return res.status(400).json({ message: formatZodError(error) });
      }
      console.error("Error creating buyer request:", error);
      res.status(500).json({ message: "Failed to create request" });
    }
  });

  // Allow buyers to close their own RFQs (buyer requests)
  app.patch('/api/marketplace/buyer-requests/:id/close', isAuthenticated, async (req: any, res) => {
    try {
      const buyerId = req.user.claims?.sub || req.user.id;
      const id = req.params.id;

      const existing = await storage.getBuyerRequestById(id);
      if (!existing) {
        return res.status(404).json({ message: "Request not found" });
      }
      if (existing.buyerId !== buyerId) {
        return res.status(403).json({ message: "You are not allowed to modify this request" });
      }

      const updated = await storage.updateBuyerRequestStatus(id, "closed");
      res.json(updated);
    } catch (error) {
      console.error("Error closing buyer request:", error);
      res.status(500).json({ message: "Failed to close request" });
    }
  });

  app.get('/api/dashboard/listings', isAuthenticated, async (req: any, res) => {
    try {
      const sellerId = req.user.claims?.sub || req.user.id;
      const listings = await storage.getListingsBySellerId(sellerId);
      res.json(listings);
    } catch (error) {
      console.error("Error fetching user listings:", error);
      res.status(500).json({ message: "Failed to fetch listings" });
    }
  });

  app.patch('/api/marketplace/listings/:id', isAuthenticated, isAdmin, requireAdminPermission('canManageListings'), async (req, res) => {
    try {
      const validatedData = insertMarketplaceListingSchema.partial().parse(req.body);
      const listing = await storage.updateMarketplaceListing(req.params.id, validatedData);
      res.json(listing);
    } catch (error: any) {
      if (error instanceof ZodError) {
        console.error("Validation error updating listing:", formatZodError(error));
        return res.status(400).json({ message: formatZodError(error) });
      }
      console.error("Error updating listing:", error);
      res.status(500).json({ message: "Failed to update listing" });
    }
  });

  app.delete('/api/marketplace/listings/:id', isAuthenticated, isAdmin, requireAdminPermission('canManageListings'), async (req, res) => {
    try {
      await storage.deleteMarketplaceListing(req.params.id);
      res.json({ success: true });
    } catch (error) {
      console.error("Error deleting listing:", error);
      res.status(500).json({ message: "Failed to delete listing" });
    }
  });

  app.patch('/api/marketplace/listings/:id/close', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims?.sub || req.user.id;
      const user = await storage.getUserById(userId);
      const listing = await storage.getMarketplaceListingById(req.params.id);
      
      if (!listing) {
        return res.status(404).json({ message: "Listing not found" });
      }
      
      if (user?.role !== 'admin' && listing.sellerId !== userId) {
        return res.status(403).json({ message: "Only the seller or admin can close this listing" });
      }
      
      const closedListing = await storage.closeMarketplaceListing(req.params.id);
      res.json(closedListing);
    } catch (error) {
      console.error("Error closing listing:", error);
      res.status(500).json({ message: "Failed to close listing" });
    }
  });

  // ========================================================================
  // Message Thread Routes
  // ========================================================================
  app.post('/api/threads', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims?.sub || req.user.id;
      const { projectId, listingId, title } = req.body;

      if (!projectId && !listingId) {
        return res.status(400).json({ message: "Either projectId or listingId is required" });
      }

      const currentUser = await storage.getUserById(userId);
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }

      let buyerId: string | null = userId;
      let sellerId: string | null = null;
      let adminId: string | null = null;
      let threadTitle = title as string | undefined;

      const adminUser = await storage.getAdminUser();
      adminId = adminUser?.id || null;

      if (projectId) {
        const project = await storage.getProjectById(projectId);
        if (!project) {
          return res.status(404).json({ message: "Project not found" });
        }

        // Project interests should go to the project owner
        sellerId = project.ownerId;
        threadTitle = threadTitle || `Inquiry about: ${project.name}`;
      } else if (listingId) {
        const listing = await storage.getMarketplaceListingById(listingId);
        if (!listing) {
          return res.status(404).json({ message: "Listing not found" });
        }

        // Listing inquiries should go to the listing's seller
        sellerId = listing.sellerId;
        threadTitle = threadTitle || `Inquiry about: ${listing.title}`;
      }

      const thread = await storage.createMessageThread({
        title: threadTitle!,
        type: projectId ? 'project_interest' : 'marketplace_inquiry',
        projectId,
        listingId,
        buyerId,
        sellerId,
        adminId,
        createdBy: userId,
        status: 'open',
      });

      res.json(thread);
    } catch (error: any) {
      console.error("Error creating thread:", error);
      res.status(500).json({ message: "Failed to create thread" });
    }
  });

  app.get('/api/threads', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims?.sub || req.user.id;
      const threads = await storage.getThreadsByUserId(userId);
      res.json(threads);
    } catch (error) {
      console.error("Error fetching threads:", error);
      res.status(500).json({ message: "Failed to fetch threads" });
    }
  });

  // Admin endpoint to get support tickets (PRIVACY: only support tickets, never buyer-seller conversations)
  app.get('/api/threads/all', isAuthenticated, isAdmin, async (req: any, res) => {
    try {
      // PRIVACY CONTROL: Admins ONLY see support tickets (isAdminSupport=true)
      // They can NEVER see buyer-seller marketplace conversations
      const status = req.query.status as string | undefined;
      const priority = req.query.priority as string | undefined;
      const assignedAdminId = req.query.assignedAdminId as string | undefined;

      const tickets = await storage.getAdminSupportTickets({ status, priority, assignedAdminId });
      res.json(tickets);
    } catch (error) {
      console.error("Error fetching admin support tickets:", error);
      res.status(500).json({ message: "Failed to fetch support tickets" });
    }
  });

  // Admin endpoint to get categorized support tickets
  app.get('/api/admin/threads/categorized', isAuthenticated, isAdmin, async (req: any, res) => {
    try {
      // PRIVACY CONTROL: Only support tickets
      const allTickets = await storage.getAdminSupportTickets();
      
      const open = allTickets.filter(t => t.ticketStatus === 'open');
      const inProgress = allTickets.filter(t => t.ticketStatus === 'in_progress');
      const waitingUser = allTickets.filter(t => t.ticketStatus === 'waiting_user');
      const resolved = allTickets.filter(t => t.ticketStatus === 'resolved');
      
      res.json({
        open,
        inProgress,
        waitingUser,
        resolved,
      });
    } catch (error) {
      console.error("Error fetching categorized support tickets:", error);
      res.status(500).json({ message: "Failed to fetch support tickets" });
    }
  });

  app.get('/api/threads/:id', isAuthenticated, async (req: any, res) => {
    try {
      const thread = await storage.getThreadById(req.params.id);
      if (!thread) {
        return res.status(404).json({ message: "Thread not found" });
      }
      res.json(thread);
    } catch (error) {
      console.error("Error fetching thread:", error);
      res.status(500).json({ message: "Failed to fetch thread" });
    }
  });

  // Return thread and participant (buyer/seller) details for UI header
  app.get('/api/threads/:id/details', isAuthenticated, async (req: any, res) => {
    try {
      const threadId = req.params.id;
      const details = await storage.getThreadWithParticipants(threadId);
      if (!details) return res.status(404).json({ message: 'Thread not found' });
      res.json(details);
    } catch (error) {
      console.error('Error fetching thread details:', error);
      res.status(500).json({ message: 'Failed to fetch thread details' });
    }
  });

  app.get('/api/threads/:id/messages', isAuthenticated, async (req: any, res) => {
    try {
      const messages = await storage.getMessagesByThreadId(req.params.id);
      res.json(messages);
    } catch (error) {
      console.error("Error fetching thread messages:", error);
      res.status(500).json({ message: "Failed to fetch messages" });
    }
  });

  app.post('/api/threads/:id/messages', isAuthenticated, async (req: any, res) => {
    try {
      const senderId = req.user.claims?.sub || req.user.id;
      const threadId = req.params.id;

      const thread = await storage.getThreadById(threadId);
      if (!thread) {
        return res.status(404).json({ message: "Thread not found" });
      }

      const sender = await storage.getUserById(senderId);
      if (!sender) {
        return res.status(404).json({ message: "User not found" });
      }

      const receiverId = senderId === thread.buyerId ? thread.sellerId : thread.buyerId;

      const validatedData = insertMessageSchema.parse({
        threadId,
        senderId,
        receiverId,
        subject: req.body.subject || thread.title,
        content: req.body.content,
        relatedProjectId: thread.projectId,
        relatedListingId: thread.listingId,
      });

      const message = await storage.createMessage(validatedData);
      await storage.updateThreadLastMessage(threadId);
      
      // Log activity
      try {
        await storage.createActivityLog({
          userId: senderId,
          activityType: 'message_sent',
          description: `Sent message in thread: "${thread.title || threadId}"`,
            ipAddress: (req.headers['x-forwarded-for'] as string)?.split(',')[0]?.trim() || (req.headers['x-real-ip'] as string) || req.ip || req.socket.remoteAddress || null,
          userAgent: req.get('user-agent') || null,
          metadata: { threadId, messageId: message.id, receiverId },
        });
      } catch (logError) {
        console.error('[ACTIVITY LOG] Failed to log message:', logError);
      }

      res.json(message);
    } catch (error: any) {
      if (error instanceof ZodError) {
        console.error("Validation error creating message:", formatZodError(error));
        return res.status(400).json({ message: formatZodError(error) });
      }
      console.error("Error creating message:", error);
      res.status(500).json({ message: "Failed to send message" });
    }
  });

  app.patch('/api/threads/:id/close', isAuthenticated, async (req: any, res) => {
    try {
      const thread = await storage.closeThread(req.params.id);
      res.json(thread);
    } catch (error) {
      console.error("Error closing thread:", error);
      res.status(500).json({ message: "Failed to close thread" });
    }
  });

  // ========================================================================
  // Support Ticket Routes (Privacy-Compliant Admin Support Only)
  // ========================================================================

  // User creates a support ticket
  app.post('/api/support/tickets', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims?.sub || req.user.id;
      const { title, description, priority } = req.body;

      if (!title || !description) {
        return res.status(400).json({ message: "Title and description are required" });
      }

      const ticket = await storage.createSupportTicket(userId, title, description, priority);
      
      // Create first message in the ticket thread
      await storage.createMessage({
        threadId: ticket.id,
        senderId: userId,
        receiverId: 'admin', // Will be matched to actual admin later
        subject: title,
        content: description,
        context: 'general',
      });

      res.json(ticket);
    } catch (error) {
      console.error("Error creating support ticket:", error);
      res.status(500).json({ message: "Failed to create support ticket" });
    }
  });

  // Admin claims a support ticket
  app.post('/api/admin/support/tickets/:id/claim', isAuthenticated, isAdmin, async (req: any, res) => {
    try {
      const adminId = req.user.claims?.sub || req.user.id;
      const ticketId = req.params.id;

      const ticket = await storage.claimSupportTicket(ticketId, adminId);
      res.json(ticket);
    } catch (error) {
      console.error("Error claiming support ticket:", error);
      res.status(500).json({ message: "Failed to claim support ticket" });
    }
  });

  // Admin resolves a support ticket
  app.patch('/api/admin/support/tickets/:id/resolve', isAuthenticated, isAdmin, async (req: any, res) => {
    try {
      const ticketId = req.params.id;
      const { notes } = req.body;

      const ticket = await storage.resolveSupportTicket(ticketId, notes);
      res.json(ticket);
    } catch (error) {
      console.error("Error resolving support ticket:", error);
      res.status(500).json({ message: "Failed to resolve support ticket" });
    }
  });

  // Admin gets all support tickets (with filtering)
  app.get('/api/admin/support/tickets', isAuthenticated, isAdmin, async (req: any, res) => {
    try {
      const status = req.query.status as string | undefined;
      const priority = req.query.priority as string | undefined;
      const assignedAdminId = req.query.assignedAdminId as string | undefined;

      const tickets = await storage.getAdminSupportTickets({ status, priority, assignedAdminId });
      res.json(tickets);
    } catch (error) {
      console.error("Error fetching support tickets:", error);
      res.status(500).json({ message: "Failed to fetch support tickets" });
    }
  });

  // Update a support ticket's status
  app.patch('/api/threads/:id/ticket-status', isAuthenticated, isAdmin, async (req: any, res) => {
    try {
      const ticketId = req.params.id;
      const { status } = req.body;

      if (!status) {
        return res.status(400).json({ message: "Status is required" });
      }

      const validStatuses = ['open', 'in_progress', 'waiting_user', 'resolved'];
      if (!validStatuses.includes(status)) {
        return res.status(400).json({ message: "Invalid status value" });
      }

      const ticket = await storage.updateTicketStatus(ticketId, status);
      if (!ticket) {
        return res.status(404).json({ message: "Ticket not found" });
      }

      res.json(ticket);
    } catch (error) {
      console.error("Error updating ticket status:", error);
      res.status(500).json({ message: "Failed to update ticket status" });
    }
  });

  // Update a support ticket's priority
  app.patch('/api/threads/:id/ticket-priority', isAuthenticated, isAdmin, async (req: any, res) => {
    try {
      const ticketId = req.params.id;
      const { priority } = req.body;

      if (!priority) {
        return res.status(400).json({ message: "Priority is required" });
      }

      const validPriorities = ['low', 'normal', 'high', 'urgent'];
      if (!validPriorities.includes(priority)) {
        return res.status(400).json({ message: "Invalid priority value" });
      }

      const ticket = await storage.updateTicketPriority(ticketId, priority);
      if (!ticket) {
        return res.status(404).json({ message: "Ticket not found" });
      }

      res.json(ticket);
    } catch (error) {
      console.error("Error updating ticket priority:", error);
      res.status(500).json({ message: "Failed to update ticket priority" });
    }
  });

  // Update a support ticket's assignee
  app.patch('/api/threads/:id/ticket-assign', isAuthenticated, isAdmin, async (req: any, res) => {
    try {
      const ticketId = req.params.id;
      const { assignedAdminId } = req.body;

      const ticket = await storage.updateTicketAssignee(ticketId, assignedAdminId);
      if (!ticket) {
        return res.status(404).json({ message: "Ticket not found" });
      }

      res.json(ticket);
    } catch (error) {
      console.error("Error updating ticket assignee:", error);
      res.status(500).json({ message: "Failed to update ticket assignee" });
    }
  });

  // Admin analytics summary
  app.get('/api/admin/analytics', isAuthenticated, isAdmin, async (req: any, res) => {
    try {
      const summary = await storage.getAnalyticsSummary();
      return res.json(summary);
    } catch (err) {
      console.error('Analytics error', err);
      return res.status(500).json({ error: 'Failed to fetch analytics' });
    }
  });

  // ========================================================================
  // AI Assistant Chat (Gemini 1.5 Flash)
  // ========================================================================
  app.post("/api/assistant/chat", async (req: any, res) => {
    try {
      const userId = req.user ? (req.user.claims?.sub || req.user.id) : null;
      const { message, history } = req.body as {
        message?: string;
        history?: ChatHistoryItem[];
      };

      if (!message || typeof message !== "string") {
        return res.status(400).json({ message: "message is required" });
      }

      const safeHistory: ChatHistoryItem[] = Array.isArray(history)
        ? history
            .filter((h: any) => h && typeof h.content === "string")
            .map((h: any) => ({
              role: h.role === "assistant" ? "assistant" : "user",
              content: h.content,
            }))
        : [];

      let reply = "";

      // Priority: HF Inference API (if configured)
      const hfApiKey = process.env.HF_API_KEY;
      const hfModel = process.env.HF_MODEL || "deepseek-ai/DeepSeek-V3.2:novita";

      // If the configured HF model looks like a modern/chat model (e.g. contains
      // "llama" or a provider slash), prefer the router endpoint which is
      // required by many newer models. Set HF_USE_ROUTER at runtime so
      // `askHuggingFace` will use the router path.
      try {
        const m = String(hfModel || "").toLowerCase();
        if (!process.env.HF_USE_ROUTER && (m.includes("llama") || hfModel.includes("/"))) {
          process.env.HF_USE_ROUTER = "1";
          console.debug("HF_USE_ROUTER enabled for model:", hfModel);
        }
      } catch (e) {
        /* ignore */
      }

      if (hfApiKey) {
        try {
          const prompt = formatChatPrompt(message, safeHistory);
          reply = await askHuggingFace(hfModel, prompt, hfApiKey);
        } catch (hfErr) {
          console.error("HF Inference failed, falling back to Gemini/local:", hfErr);
          reply = await askSupportBot(message, safeHistory);
        }
