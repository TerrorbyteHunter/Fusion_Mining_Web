    try {
      const projects = await storage.getProjects();
      const isAdmin = req.user && req.user.role === 'admin';
      
      const filteredProjects = isAdmin 
        ? projects 
        : projects.filter(p => p.status === 'active');
      
      res.json(filteredProjects);
    } catch (error) {
      console.error("Error fetching projects:", error);
      res.status(500).json({ message: "Failed to fetch projects" });
    }
  });

  app.get('/api/projects/:id', async (req, res) => {
    try {
      const project = await storage.getProjectById(req.params.id);
      if (!project) {
        return res.status(404).json({ message: "Project not found" });
      }
      res.json(project);
    } catch (error) {
      console.error("Error fetching project:", error);
      res.status(500).json({ message: "Failed to fetch project" });
    }
  });

  app.post('/api/projects', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims?.sub || req.user.id;
      // Defensive check: ensure we have a valid user ID
      if (!userId) {
        return res.status(401).json({ message: "Authentication required" });
      }
      const validatedData = insertProjectSchema.parse(req.body);
      // Always set ownerId from authenticated user to prevent spoofing
      const projectData = {
        ...validatedData,
        ownerId: userId,
      };
      const project = await storage.createProject(projectData);
      res.json(project);
    } catch (error: any) {
      if (error instanceof ZodError) {
        console.error("Validation error creating project:", formatZodError(error));
        return res.status(400).json({ message: formatZodError(error) });
      }
      console.error("Error creating project:", error);
      res.status(500).json({ message: "Failed to create project" });
    }
  });

  app.patch('/api/projects/:id', isAuthenticated, isAdmin, async (req: any, res) => {
    try {
      const validatedData = insertProjectSchema.partial().parse(req.body);
      // Prevent changing ownerId via update - only admins should update projects anyway
      const { ownerId, ...updateData } = validatedData;
      const project = await storage.updateProject(req.params.id, updateData);
      res.json(project);
    } catch (error: any) {
      if (error instanceof ZodError) {
        console.error("Validation error updating project:", formatZodError(error));
        return res.status(400).json({ message: formatZodError(error) });
      }
      console.error("Error updating project:", error);
      res.status(500).json({ message: "Failed to update project" });
    }
  });

  app.delete('/api/projects/:id', isAuthenticated, isAdmin, async (req, res) => {
    try {
      await storage.deleteProject(req.params.id);
      res.json({ success: true });
    } catch (error) {
      console.error("Error deleting project:", error);
      res.status(500).json({ message: "Failed to delete project" });
    }
  });

  app.patch('/api/projects/:id/close', isAuthenticated, async (req, res) => {
    try {
      const project = await storage.closeProject(req.params.id);
      res.json(project);
    } catch (error) {
      console.error("Error closing project:", error);
      res.status(500).json({ message: "Failed to close project" });
    }
  });

  app.post('/api/projects/interest', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims?.sub || req.user.id;
      const { projectId, listingId } = req.body;

      if (projectId) {
        const hasInterest = await storage.checkUserHasExpressedInterest(userId, projectId);
        if (hasInterest) {
          return res.status(400).json({ message: "You have already expressed interest in this project" });
        }
      }

      const validatedData = insertExpressInterestSchema.parse({
        ...req.body,
        userId,
      });
      const interest = await storage.expressProjectInterest(validatedData);

      const buyer = await storage.getUserById(userId);
      
      if (projectId) {
        const project = await storage.getProjectById(projectId);
        
        if (project && buyer && project.ownerId) {
          const projectOwner = await storage.getUserById(project.ownerId);
          
          if (projectOwner) {
            // Create direct thread between buyer and project owner
            const thread = await storage.createMessageThread({
              title: `Inquiry about: ${project.name}`,
              type: 'project_interest',
              projectId,
              buyerId: userId,
              sellerId: project.ownerId,
              adminId: null,
              createdBy: userId,
              context: 'project_interest',
              status: 'open',
            });

            // Notify project owner of interest
            await storage.createNotification({
              userId: project.ownerId,
              type: 'interest_received',
              title: 'New Interest in Your Project',
              message: `${buyer.firstName} ${buyer.lastName} expressed interest in ${project.name}`,
              link: `/dashboard/messages`,
            });

            // Send welcome message from owner to buyer
            const ownerName = `${projectOwner.firstName || ''} ${projectOwner.lastName || ''}`.trim() || 'Project Owner';
            const buyerName = `${buyer.firstName || ''} ${buyer.lastName || ''}`.trim() || 'there';
            
            await storage.createMessage({
              threadId: thread.id,
              senderId: project.ownerId,
              receiverId: userId,
              subject: `Re: Inquiry about ${project.name}`,
              content: `Hello ${buyerName},\n\nThank you for your interest in ${project.name}. I'm ${ownerName}, the project owner. I'd be happy to discuss this opportunity with you.\n\nPlease feel free to ask any questions you may have.\n\nBest regards,\n${ownerName}`,
              context: 'project_interest',
              relatedProjectId: projectId,
              isAutoRelay: true,
            });
          }
        }
      } else if (listingId) {
        const listing = await storage.getMarketplaceListingById(listingId);
        const seller = listing ? await storage.getUserById(listing.sellerId) : null;
        
        if (listing && buyer && seller) {
          // Create direct thread between buyer and seller
          const thread = await storage.createMessageThread({
            title: `Inquiry about: ${listing.title}`,
            type: 'marketplace_inquiry',
            listingId,
            buyerId: userId,
            sellerId: listing.sellerId,
            adminId: null,
            createdBy: userId,
            context: 'marketplace',
            status: 'open',
          });

          // Notify seller of interest
          await storage.createNotification({
            userId: seller.id,
            type: 'interest_received',
            title: 'New Interest in Your Listing',
            message: `${buyer.firstName} ${buyer.lastName} expressed interest in ${listing.title}`,
            link: `/dashboard/messages`,
          });

          // Send welcome message from seller to buyer
          const sellerName = `${seller.firstName || ''} ${seller.lastName || ''}`.trim() || 'Seller';
          const buyerName = `${buyer.firstName || ''} ${buyer.lastName || ''}`.trim() || 'there';
          
          await storage.createMessage({
            threadId: thread.id,
            senderId: listing.sellerId,
            receiverId: userId,
            subject: `Re: Inquiry about ${listing.title}`,
            content: `Hello ${buyerName},\n\nThank you for your interest in ${listing.title}. I'm ${sellerName}, the seller. I'd be happy to provide more information and answer any questions you might have.\n\nFeel free to reach out with your questions.\n\nBest regards,\n${sellerName}`,
            context: 'marketplace',
            relatedListingId: listingId,
            isAutoRelay: true,
          });
        }
      }

      // Create activity log
      await storage.createActivityLog({
        userId,
        activityType: 'interest_expressed',
        description: projectId ? `User expressed interest in project ${projectId}` : `User expressed interest in listing ${listingId}`,
        ipAddress: req.ip,
        userAgent: req.get('user-agent'),
      });

      // Notify all admin users (use 'interest_received' notification type)
      const adminUsers = await storage.getUsersByRole('admin');
      // Resolve a short title for the target (project or listing)
      let titleText = '';
      if (projectId) {
        const proj = await storage.getProjectById(projectId);
        titleText = proj?.name || projectId;
      } else if (listingId) {
        const list = await storage.getMarketplaceListingById(listingId);
        titleText = list?.title || listingId;
      }

      for (const admin of adminUsers) {
        await storage.createNotification({
          userId: admin.id,
          type: 'interest_received',
          title: 'New Interest Expression',
          message: `${buyer?.firstName || ''} ${buyer?.lastName || ''} expressed interest in ${projectId ? 'project' : 'listing'}: ${titleText}`,
          link: projectId ? `/projects/${projectId}` : `/marketplace/${listingId}`,
        });
      }

      res.json(interest);
    } catch (error: any) {
      if (error instanceof ZodError) {
        console.error("Validation error expressing interest:", formatZodError(error));
        return res.status(400).json({ message: formatZodError(error) });
      }
      console.error("Error expressing interest:", error);
      res.status(500).json({ message: "Failed to express interest" });
    }
  });

  app.get('/api/projects/:id/has-interest', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims?.sub || req.user.id;
      const projectId = req.params.id;
      const hasInterest = await storage.checkUserHasExpressedInterest(userId, projectId);
      res.json({ hasInterest });
    } catch (error) {
      console.error("Error checking interest:", error);
      res.status(500).json({ message: "Failed to check interest" });
    }
  });

  app.get('/api/admin/projects-interest', isAuthenticated, isAdmin, async (req, res) => {
    try {
      const interests = await storage.getAllExpressedInterests();
      res.json(interests);
    } catch (error) {
      console.error("Error fetching expressed interests:", error);
      res.status(500).json({ message: "Failed to fetch expressed interests" });
    }
  });

  // ========================================================================
  // Marketplace Routes
  // ========================================================================
  app.get('/api/marketplace/listings', async (req: any, res) => {
    try {
      const { type, status } = req.query;
      const isAdmin = req.user && req.user.role === 'admin';
      const listings = await storage.getMarketplaceListings({
        type: type as string,
        status: status as string,
      });
      
      const filteredListings = isAdmin 
        ? listings 
        : listings.filter(l => l.status === 'approved');
      
      res.json(filteredListings);
    } catch (error) {
      console.error("Error fetching listings:", error);
      res.status(500).json({ message: "Failed to fetch listings" });
    }
  });

  // Dashboard: get current user's listings (sellers)
  app.get('/api/dashboard/listings', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims?.sub || req.user.id;
      // If user is seller, return their listings; otherwise return empty array
      const listings = await storage.getListingsBySellerId(userId);
      res.json(listings || []);
    } catch (error) {
      console.error('Error fetching dashboard listings:', error);
      res.status(500).json({ message: 'Failed to fetch dashboard listings' });
    }
  });

  // Return a single listing including basic seller info (used by client when messages
  // don't include the listing payload).
  app.get('/api/marketplace/listings/:id', async (req, res) => {
    try {
      const listingId = req.params.id;
      const listing = await storage.getMarketplaceListingById(listingId);
      if (!listing) return res.status(404).json({ message: 'Listing not found' });
      const seller = listing.sellerId ? await storage.getUserById(listing.sellerId) : null;
      res.json({
        ...listing,
        sellerName: seller ? `${seller.firstName || ''} ${seller.lastName || ''}`.trim() : undefined,
      });
    } catch (error) {
      console.error('Error fetching listing:', error);
      res.status(500).json({ message: 'Failed to fetch listing' });
    }
  });

  app.post('/api/marketplace/listings', isAuthenticated, isSeller, async (req: any, res) => {
    try {
      const sellerId = req.user.claims?.sub || req.user.id;
      const validatedData = insertMarketplaceListingSchema.parse({
        ...req.body,
        sellerId,
      });
      const listing = await storage.createMarketplaceListing(validatedData);
      
      // Log activity
      try {
        await storage.createActivityLog({
          userId: sellerId,
          activityType: 'listing_created',
          description: `Created marketplace listing: "${listing.title || listing.id}"`,
            ipAddress: (req.headers['x-forwarded-for'] as string)?.split(',')[0]?.trim() || (req.headers['x-real-ip'] as string) || req.ip || req.socket.remoteAddress || null,
          userAgent: req.get('user-agent') || null,
          metadata: { listingId: listing.id, listingType: listing.listingType },
        });
      } catch (logError) {
        console.error('[ACTIVITY LOG] Failed to log listing creation:', logError);
      }
      
      res.json(listing);
